{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":1},{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":1},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":1},{"_id":"themes/apollo/source/avatar2.jpg","path":"avatar2.jpg","modified":1},{"_id":"themes/apollo/source/avatar1.jpg","path":"avatar1.jpg","modified":1},{"_id":"themes/apollo/source/avatar.jpg","path":"avatar.jpg","modified":1},{"_id":"source/CNAME_","path":"CNAME_","modified":1},{"_id":"source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":1},{"_id":"source/images/QQ20180617-174124@2x.png","path":"images/QQ20180617-174124@2x.png","modified":1},{"_id":"source/images/QQ20180617-173851@2x.png","path":"images/QQ20180617-173851@2x.png","modified":1},{"_id":"source/images/QQ20180617-173229@2x.png","path":"images/QQ20180617-173229@2x.png","modified":1},{"_id":"source/images/QQ20180617-165142@2x.png","path":"images/QQ20180617-165142@2x.png","modified":1},{"_id":"source/images/QQ20180617-165008@2x.png","path":"images/QQ20180617-165008@2x.png","modified":1},{"_id":"source/images/QQ20180617-164649@2x.png","path":"images/QQ20180617-164649@2x.png","modified":1},{"_id":"source/images/Building Faster in Xcode_.png","path":"images/Building Faster in Xcode_.png","modified":1},{"_id":"source/images/Building Faster in Xcode.png","path":"images/Building Faster in Xcode.png","modified":1},{"_id":"source/images/15292356504822.jpg","path":"images/15292356504822.jpg","modified":1},{"_id":"source/images/15292355397528.jpg","path":"images/15292355397528.jpg","modified":1},{"_id":"source/images/15292355026463.jpg","path":"images/15292355026463.jpg","modified":1},{"_id":"source/images/15292354967107.jpg","path":"images/15292354967107.jpg","modified":1},{"_id":"source/images/15292354795777.jpg","path":"images/15292354795777.jpg","modified":1},{"_id":"source/images/15292352697835.jpg","path":"images/15292352697835.jpg","modified":1},{"_id":"source/images/15292351447821.jpg","path":"images/15292351447821.jpg","modified":1},{"_id":"source/images/15292346898606.jpg","path":"images/15292346898606.jpg","modified":1},{"_id":"source/images/15292346436023.jpg","path":"images/15292346436023.jpg","modified":1},{"_id":"source/images/15292313838157.jpg","path":"images/15292313838157.jpg","modified":1},{"_id":"source/images/15292313035255.jpg","path":"images/15292313035255.jpg","modified":1},{"_id":"source/images/15292312680309.jpg","path":"images/15292312680309.jpg","modified":1},{"_id":"source/images/15292312542417.jpg","path":"images/15292312542417.jpg","modified":1},{"_id":"source/images/15292312274443.jpg","path":"images/15292312274443.jpg","modified":1},{"_id":"source/images/15292308090026.jpg","path":"images/15292308090026.jpg","modified":1},{"_id":"source/images/15292305743843.jpg","path":"images/15292305743843.jpg","modified":1},{"_id":"source/images/15292305166448.jpg","path":"images/15292305166448.jpg","modified":1},{"_id":"source/images/15292304507458.jpg","path":"images/15292304507458.jpg","modified":1},{"_id":"source/images/15292304002286.jpg","path":"images/15292304002286.jpg","modified":1},{"_id":"source/images/15292302723971.jpg","path":"images/15292302723971.jpg","modified":1},{"_id":"source/images/15292300070030.jpg","path":"images/15292300070030.jpg","modified":1},{"_id":"source/images/15292297716350.jpg","path":"images/15292297716350.jpg","modified":1},{"_id":"source/images/15292296942668.jpg","path":"images/15292296942668.jpg","modified":1},{"_id":"source/images/15292295109399.jpg","path":"images/15292295109399.jpg","modified":1},{"_id":"source/images/15292294983715.jpg","path":"images/15292294983715.jpg","modified":1},{"_id":"source/images/15292294774311.jpg","path":"images/15292294774311.jpg","modified":1},{"_id":"source/images/15292294609151.jpg","path":"images/15292294609151.jpg","modified":1},{"_id":"source/images/15292293472562.jpg","path":"images/15292293472562.jpg","modified":1}],"Cache":[{"_id":"source/_posts/408-building-faster-in-xcode.md","shasum":"6bdfa5f94d2ff7bb9ec9a7ffb86a9f4bd97c133d","modified":1529238689059},{"_id":"source/CNAME_","shasum":"cf3446bacd3f04cf9f93fc86cd2af1c9edfbfeba","modified":1483417736000},{"_id":"source/_posts/Runtime-tabBarItem.md","shasum":"28a23b2719daf90bbf83e081322e4bc4c2dd2102","modified":1483417736000},{"_id":"source/_posts/RSA-SHA.md","shasum":"421b13651b5adb305a43bd2f200397a05c7d212b","modified":1483417736000},{"_id":"source/_posts/Socket.md","shasum":"c765fb52da056befb6ba062fae3a9d3d9db119d4","modified":1483417736000},{"_id":"source/_posts/YYKit-pthread.md","shasum":"411fad792112b8b25ed9d6eaf3e21c027f24d3f2","modified":1483417736000},{"_id":"source/_posts/YYCache-analyzing.md","shasum":"791644c72e2bb437ca279b1598510374dbb2c1dc","modified":1483417736000},{"_id":"source/_posts/alfred-use.md","shasum":"efa00c4d42bd82f0eac0130105cf761f4e08d650","modified":1483440615000},{"_id":"source/_posts/git-commands.md","shasum":"19235aaff01a31b9f7824c13a55bce2b663bcad5","modified":1488982359000},{"_id":"source/_posts/sketch-makeicons.md","shasum":"5ada769f420a87c13c1afe220922676e09ff6c0c","modified":1483417736000},{"_id":"source/_posts/xctool-package.md","shasum":"add599511f6d00f3d8031a2f3f75684ec1093a6a","modified":1483417736000},{"_id":"source/about/index.md","shasum":"f659e89ebbd7d656208371abfca5401de89e1e09","modified":1452924437000},{"_id":"source/categories/index.md","shasum":"283a947e797500aa6f9398ecfdcce410670b9a2d","modified":1452924164000},{"_id":"source/_posts/执着.md","shasum":"7daa87a86c5d59312293588c3f9a49d2e12a2c57","modified":1483417736000},{"_id":"source/images/15292304002286.jpg","shasum":"96d880ec6a1b33e702cd108322eef8769cf2fa3b","modified":1529230400245},{"_id":"source/instagram/index.md","shasum":"ce39a108289ee00c6c55d4c50e628f99bc26de18","modified":1452920289000},{"_id":"source/tags/index.md","shasum":"b5a8983835c5e8b3f6b50413ef22f325c4e75f35","modified":1452924126000},{"_id":"source/uploads/avatar.jpg","shasum":"cd576a77b0e3fc0cd4bda8f35afc9a23755a890d","modified":1452919442000},{"_id":"source/images/15292300070030.jpg","shasum":"09a161f4db7202243203b098381fb436ef9f19c9","modified":1529230007028},{"_id":"source/images/15292297716350.jpg","shasum":"0e14e584d22cf1fc1616d480b958a8ec7d2eac75","modified":1529229771665},{"_id":"source/images/15292302723971.jpg","shasum":"873fdecbc750f19d62e9f10afe7188c540f9e82f","modified":1529230272429},{"_id":"source/images/15292304507458.jpg","shasum":"0ae73db16f7c42494003e9556c70193deffbe10b","modified":1529230450769},{"_id":"source/images/15292305166448.jpg","shasum":"7cafbb0c917255df3b9e0add77b41fc0311436bc","modified":1529230516676},{"_id":"source/images/15292352697835.jpg","shasum":"ddb983842e858dd7a4159d9938455d2980174f20","modified":1529235269810},{"_id":"source/images/15292354795777.jpg","shasum":"d6a61cb4b99c40d3deb82da3200816cc02e1348e","modified":1529235479591},{"_id":"source/images/15292355026463.jpg","shasum":"d6a61cb4b99c40d3deb82da3200816cc02e1348e","modified":1529235502660},{"_id":"source/images/15292355397528.jpg","shasum":"27d0b007e24920ef2f4edaddc31c6ce4a0802f67","modified":1529235539774},{"_id":"source/images/15292354967107.jpg","shasum":"d6a61cb4b99c40d3deb82da3200816cc02e1348e","modified":1529235496725},{"_id":"source/images/QQ20180617-164649@2x.png","shasum":"e95741841ccda49acb917ed6e0d74e89bbf1130e","modified":1529225212973},{"_id":"source/images/QQ20180617-165142@2x.png","shasum":"c40b1c948fe84ebd067c20741ea3858afc44d72d","modified":1529225505186},{"_id":"source/images/Building Faster in Xcode_.png","shasum":"34a762a7f7bc95b625191003d9f84a6d7c5c85c0","modified":1529236413420},{"_id":"source/images/QQ20180617-173229@2x.png","shasum":"681c018a5d44326088e0cc7c3623beb88238c422","modified":1529227951715},{"_id":"source/images/15292305743843.jpg","shasum":"e38eebecccd6e15e9b0617caa71757b5c37b309d","modified":1529230574439},{"_id":"source/images/15292308090026.jpg","shasum":"719de20193c265e8ccbce9dd7a94b80a422c509b","modified":1529230809034},{"_id":"source/images/15292312274443.jpg","shasum":"860430047f83b249a036877b25874489e922ef2c","modified":1529231227497},{"_id":"source/images/15292313035255.jpg","shasum":"d185e2fae935fc8dc966b7a0969d441e4578a701","modified":1529231303569},{"_id":"source/images/15292312680309.jpg","shasum":"a5a3b666064dbcb791ce9224b67984dc61aaa844","modified":1529231268076},{"_id":"source/images/15292313838157.jpg","shasum":"6bd466fa053510b6757f503c36530da9ac87c2f1","modified":1529231383863},{"_id":"source/images/Building Faster in Xcode.png","shasum":"19d960b50ead78bb203de75775158384dc8b561b","modified":1529236325415},{"_id":"source/images/QQ20180617-165008@2x.png","shasum":"7f4d0a04e60de6f34bc5bd589da1d946ffb02af0","modified":1529225424242},{"_id":"source/images/15292346436023.jpg","shasum":"cde509a8dd7dcf11fba9f084dafed6787e7b2187","modified":1529234643657},{"_id":"source/images/15292346898606.jpg","shasum":"1fa3444ff8537a759caf374e941c6af1760ba7d3","modified":1529234689926},{"_id":"source/images/15292295109399.jpg","shasum":"7ecb63bbd02ac478a1911afe6d4da12d44ad74c0","modified":1529229511008},{"_id":"source/images/QQ20180617-173851@2x.png","shasum":"51ff09c50d0b4ba9c7b99cb02e9e7c2989ae7303","modified":1529228332726},{"_id":"themes/apollo/README.md","shasum":"fb6fbe42172a35cbdaa540a777cc4bc02add2278","modified":1472093882000},{"_id":"themes/apollo/LICENSE","shasum":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1460861213000},{"_id":"themes/apollo/_config.yml","shasum":"f1d158863424415031900df2d3c6a72f1af8b096","modified":1472109690000},{"_id":"themes/apollo/doc/doc-en.md","shasum":"d6d9756b2085cdd8ee51eb5594427e2abf170e94","modified":1460861213000},{"_id":"themes/apollo/gulpfile.js","shasum":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1460861213000},{"_id":"themes/apollo/doc/doc-zh.md","shasum":"d43c1f6bff66426744a2c6f031d19ff09cdeb2d1","modified":1460861213000},{"_id":"themes/apollo/languages/en.yml","shasum":"40292f2a48e4e6361132033a47c516cb33127b6c","modified":1460861213000},{"_id":"themes/apollo/languages/zh-cn.yml","shasum":"9e4b03e14c094000257ea254fd660dde4c7af63c","modified":1460861213000},{"_id":"themes/apollo/layout/archive.jade","shasum":"62797414355bf4474092bc3a32726c8340820ffb","modified":1460861213000},{"_id":"themes/apollo/layout/index.jade","shasum":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1460861213000},{"_id":"themes/apollo/layout/mixins/paginator.jade","shasum":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1460861213000},{"_id":"themes/apollo/layout/partial/comment.jade","shasum":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1460861213000},{"_id":"themes/apollo/layout/mixins/post.jade","shasum":"cd9447e9b0ad22213e6a17d9a9b948f9f998f921","modified":1462975735000},{"_id":"themes/apollo/layout/partial/copyright.jade","shasum":"217f8b17054e5079f2d30bb7e2e4e36c0f2161b7","modified":1472093882000},{"_id":"themes/apollo/layout/partial/head.jade","shasum":"d062dafabfe65198e5cf2ddb0e47d909885aa950","modified":1472093882000},{"_id":"themes/apollo/layout/partial/nav.jade","shasum":"c35d3061da4b053b73150d9741c542d660798270","modified":1460861213000},{"_id":"themes/apollo/layout/partial/layout.jade","shasum":"eb15573ff66bdbb110ac77cf360b740170cee738","modified":1462975735000},{"_id":"themes/apollo/layout/partial/scripts.jade","shasum":"cf3339de8979b5f75a3011f0f6b5451091b77dc8","modified":1472093882000},{"_id":"themes/apollo/package.json","shasum":"4d13f5f859db7d008f49251543a8f610b2ecabd5","modified":1472093882000},{"_id":"themes/apollo/layout/post.jade","shasum":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1462975735000},{"_id":"themes/apollo/source/_avatar.jpg","shasum":"cd576a77b0e3fc0cd4bda8f35afc9a23755a890d","modified":1472093983000},{"_id":"themes/apollo/source/avatar1.jpg","shasum":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1472093983000},{"_id":"themes/apollo/source/css/apollo.css","shasum":"2cfd049bcbad8a9a68c13299a92e993d5c92d029","modified":1472093882000},{"_id":"themes/apollo/source/favicon.png","shasum":"bd1854baae82d46b0d96212c1bedca1313056383","modified":1472100967000},{"_id":"themes/apollo/source/avatar.jpg","shasum":"b22e7fed252896bf3f7d3fa0e63b889b8fbf5311","modified":1472133412000},{"_id":"themes/apollo/source/scss/_partial/base.scss","shasum":"fe20c16c18ab76b843d0aab2e1a5cc4f5d6d64c7","modified":1472093882000},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","shasum":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1472093882000},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","shasum":"d2f740a7d48349b7536777c795f82ab740836d0f","modified":1462975735000},{"_id":"themes/apollo/source/font/sourcesanspro.woff","shasum":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1472093882000},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","shasum":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1462975735000},{"_id":"themes/apollo/source/scss/_partial/footer.scss","shasum":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1460861213000},{"_id":"themes/apollo/source/scss/_partial/header.scss","shasum":"153bde88bf8ffeae4ffd813d8cc694dd83d33d94","modified":1460861213000},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","shasum":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1462975735000},{"_id":"themes/apollo/source/scss/_partial/mq.scss","shasum":"b5eb0fb35fb275cbb6452b5d98702d461af3e6d5","modified":1460861213000},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","shasum":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1460861213000},{"_id":"themes/apollo/source/scss/_partial/post.scss","shasum":"ae780828148f79e5069b480e3576f1fea1246866","modified":1472093882000},{"_id":"themes/apollo/source/scss/apollo.scss","shasum":"153bbf882c1f6f65bb4510999b51812e20016ca7","modified":1472093882000},{"_id":"source/images/QQ20180617-174124@2x.png","shasum":"2d3ac4f46e1cab4aac468a934ae2b3256830d4d6","modified":1529228523424},{"_id":"source/images/15292351447821.jpg","shasum":"3e201bbb577f91fded02350db317392af149fc0b","modified":1529235148880},{"_id":"source/images/15292294774311.jpg","shasum":"58ec71c0110c6f7e985df4eec63540575c44ed15","modified":1529229477530},{"_id":"source/images/15292294983715.jpg","shasum":"58ec71c0110c6f7e985df4eec63540575c44ed15","modified":1529229498499},{"_id":"source/images/15292293472562.jpg","shasum":"58ec71c0110c6f7e985df4eec63540575c44ed15","modified":1529229347357},{"_id":"source/images/15292294609151.jpg","shasum":"58ec71c0110c6f7e985df4eec63540575c44ed15","modified":1529229461007},{"_id":"source/images/15292312542417.jpg","shasum":"488d273ef04998c64533247eecb18541daa2f934","modified":1529231256041},{"_id":"themes/apollo/source/avatar2.jpg","shasum":"0555d723637c4da77dbe6722d26f262802d1dcd0","modified":1472093983000},{"_id":"source/images/15292356504822.jpg","shasum":"bc18c6d66b26c7daa94456f20e3f419d4fb78906","modified":1529235652372},{"_id":"source/images/15292296942668.jpg","shasum":"5455f1fe6a3a3d22f8480b2f71f1a0ac7b6d1ce4","modified":1529229696072},{"_id":"public/scss/apollo.scss","modified":1529239320170,"shasum":"153bbf882c1f6f65bb4510999b51812e20016ca7"},{"_id":"public/font/sourcesanspro.woff2","modified":1529239320177,"shasum":"da65f527a8da65d5eb6721626d28cfdb46ab104a"},{"_id":"public/font/sourcesanspro.woff","modified":1529239320180,"shasum":"a6722c9b6439b7a020a9be3d3178970757a9265c"},{"_id":"public/favicon.png","modified":1529239320184,"shasum":"bd1854baae82d46b0d96212c1bedca1313056383"},{"_id":"public/css/apollo.css","modified":1529239320187,"shasum":"2cfd049bcbad8a9a68c13299a92e993d5c92d029"},{"_id":"public/avatar2.jpg","modified":1529239320190,"shasum":"0555d723637c4da77dbe6722d26f262802d1dcd0"},{"_id":"public/avatar1.jpg","modified":1529239320193,"shasum":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c"},{"_id":"public/avatar.jpg","modified":1529239320196,"shasum":"b22e7fed252896bf3f7d3fa0e63b889b8fbf5311"},{"_id":"public/CNAME_","modified":1529239320198,"shasum":"cf3446bacd3f04cf9f93fc86cd2af1c9edfbfeba"},{"_id":"public/uploads/avatar.jpg","modified":1529239320201,"shasum":"cd576a77b0e3fc0cd4bda8f35afc9a23755a890d"},{"_id":"public/images/QQ20180617-174124@2x.png","modified":1529239320206,"shasum":"2d3ac4f46e1cab4aac468a934ae2b3256830d4d6"},{"_id":"public/images/QQ20180617-173851@2x.png","modified":1529239320213,"shasum":"51ff09c50d0b4ba9c7b99cb02e9e7c2989ae7303"},{"_id":"public/images/QQ20180617-173229@2x.png","modified":1529239320221,"shasum":"681c018a5d44326088e0cc7c3623beb88238c422"},{"_id":"public/images/QQ20180617-165142@2x.png","modified":1529239320223,"shasum":"c40b1c948fe84ebd067c20741ea3858afc44d72d"},{"_id":"public/images/QQ20180617-165008@2x.png","modified":1529239320231,"shasum":"7f4d0a04e60de6f34bc5bd589da1d946ffb02af0"},{"_id":"public/images/QQ20180617-164649@2x.png","modified":1529239320234,"shasum":"e95741841ccda49acb917ed6e0d74e89bbf1130e"},{"_id":"public/images/Building Faster in Xcode_.png","modified":1529239320238,"shasum":"34a762a7f7bc95b625191003d9f84a6d7c5c85c0"},{"_id":"public/images/Building Faster in Xcode.png","modified":1529239320243,"shasum":"19d960b50ead78bb203de75775158384dc8b561b"},{"_id":"public/images/15292356504822.jpg","modified":1529239320250,"shasum":"bc18c6d66b26c7daa94456f20e3f419d4fb78906"},{"_id":"public/images/15292355397528.jpg","modified":1529239320254,"shasum":"27d0b007e24920ef2f4edaddc31c6ce4a0802f67"},{"_id":"public/images/15292355026463.jpg","modified":1529239320258,"shasum":"d6a61cb4b99c40d3deb82da3200816cc02e1348e"},{"_id":"public/images/15292354967107.jpg","modified":1529239320262,"shasum":"d6a61cb4b99c40d3deb82da3200816cc02e1348e"},{"_id":"public/images/15292354795777.jpg","modified":1529239320265,"shasum":"d6a61cb4b99c40d3deb82da3200816cc02e1348e"},{"_id":"public/images/15292352697835.jpg","modified":1529239320271,"shasum":"ddb983842e858dd7a4159d9938455d2980174f20"},{"_id":"public/images/15292351447821.jpg","modified":1529239320276,"shasum":"3e201bbb577f91fded02350db317392af149fc0b"},{"_id":"public/images/15292346898606.jpg","modified":1529239320281,"shasum":"1fa3444ff8537a759caf374e941c6af1760ba7d3"},{"_id":"public/images/15292346436023.jpg","modified":1529239320292,"shasum":"cde509a8dd7dcf11fba9f084dafed6787e7b2187"},{"_id":"public/images/15292313838157.jpg","modified":1529239320296,"shasum":"6bd466fa053510b6757f503c36530da9ac87c2f1"},{"_id":"public/images/15292313035255.jpg","modified":1529239320302,"shasum":"d185e2fae935fc8dc966b7a0969d441e4578a701"},{"_id":"public/images/15292312680309.jpg","modified":1529239320304,"shasum":"a5a3b666064dbcb791ce9224b67984dc61aaa844"},{"_id":"public/images/15292312542417.jpg","modified":1529239320309,"shasum":"488d273ef04998c64533247eecb18541daa2f934"},{"_id":"public/images/15292312274443.jpg","modified":1529239320313,"shasum":"860430047f83b249a036877b25874489e922ef2c"},{"_id":"public/images/15292308090026.jpg","modified":1529239320316,"shasum":"719de20193c265e8ccbce9dd7a94b80a422c509b"},{"_id":"public/images/15292305743843.jpg","modified":1529239320319,"shasum":"e38eebecccd6e15e9b0617caa71757b5c37b309d"},{"_id":"public/images/15292305166448.jpg","modified":1529239320323,"shasum":"7cafbb0c917255df3b9e0add77b41fc0311436bc"},{"_id":"public/images/15292304507458.jpg","modified":1529239320325,"shasum":"0ae73db16f7c42494003e9556c70193deffbe10b"},{"_id":"public/images/15292304002286.jpg","modified":1529239320327,"shasum":"96d880ec6a1b33e702cd108322eef8769cf2fa3b"},{"_id":"public/images/15292302723971.jpg","modified":1529239320329,"shasum":"873fdecbc750f19d62e9f10afe7188c540f9e82f"},{"_id":"public/images/15292300070030.jpg","modified":1529239320332,"shasum":"09a161f4db7202243203b098381fb436ef9f19c9"},{"_id":"public/images/15292297716350.jpg","modified":1529239320335,"shasum":"0e14e584d22cf1fc1616d480b958a8ec7d2eac75"},{"_id":"public/images/15292296942668.jpg","modified":1529239320340,"shasum":"5455f1fe6a3a3d22f8480b2f71f1a0ac7b6d1ce4"},{"_id":"public/images/15292295109399.jpg","modified":1529239320345,"shasum":"7ecb63bbd02ac478a1911afe6d4da12d44ad74c0"},{"_id":"public/images/15292294983715.jpg","modified":1529239320349,"shasum":"58ec71c0110c6f7e985df4eec63540575c44ed15"},{"_id":"public/images/15292294774311.jpg","modified":1529239320353,"shasum":"58ec71c0110c6f7e985df4eec63540575c44ed15"},{"_id":"public/images/15292294609151.jpg","modified":1529239320358,"shasum":"58ec71c0110c6f7e985df4eec63540575c44ed15"},{"_id":"public/images/15292293472562.jpg","modified":1529239320365,"shasum":"58ec71c0110c6f7e985df4eec63540575c44ed15"},{"_id":"public/tags/index.html","modified":1529239320662,"shasum":"1c4d826af807172c35b354c70504abe05e52ab57"},{"_id":"public/instagram/index.html","modified":1529239320854,"shasum":"044669f9f757d88dff2b1ada5a267830a372e09d"},{"_id":"public/categories/index.html","modified":1529239321050,"shasum":"d05f534f171d5b185cafff1f57174595de80badf"},{"_id":"public/about/index.html","modified":1529239321211,"shasum":"1c5d7b03a12db6247fdd91acc516787ed32227bd"},{"_id":"public/2018/06/17/408-building-faster-in-xcode/index.html","modified":1529239321356,"shasum":"e02801a25f7c1d169068a9b7b4dc642faf73f213"},{"_id":"public/2017/02/25/git-commands/index.html","modified":1529239321450,"shasum":"d55f53bba364339110660a1960b0b7d56d7ea5f8"},{"_id":"public/2017/01/03/alfred-use/index.html","modified":1529239321516,"shasum":"8a47214fad4cda0657eaef89a77907c92fc1af4f"},{"_id":"public/2016/09/26/sketch-makeicons/index.html","modified":1529239321577,"shasum":"7dbd32cb504f1dd2564cb7358194c5bf138ca60d"},{"_id":"public/2016/08/25/执着/index.html","modified":1529239321637,"shasum":"54f5913359a3d4c94b9e9eebb32475f52131deb9"},{"_id":"public/2016/07/18/YYCache-analyzing/index.html","modified":1529239321699,"shasum":"74ff42ae4d350501d3594ef7f8d81a2bdfdbb849"},{"_id":"public/2016/06/21/YYKit-pthread/index.html","modified":1529239321788,"shasum":"100f46e61e808a0205dcef2b36b1d98b57e39aa7"},{"_id":"public/2016/05/11/Runtime-tabBarItem/index.html","modified":1529239321871,"shasum":"165fdba5f5ea8ada0485511db0568ba6eddcd174"},{"_id":"public/2016/02/13/xctool-package/index.html","modified":1529239321953,"shasum":"eeeeb202316e22afea24258079510575ad8e4ce0"},{"_id":"public/2016/01/16/Socket/index.html","modified":1529239322045,"shasum":"de8deb9af9f921d21fba50036e829f4368117bbc"},{"_id":"public/2016/01/12/RSA-SHA/index.html","modified":1529239322129,"shasum":"5a6435dbf3b02fdd1c9235ef81cfb5e294bbd2ea"},{"_id":"public/archives/index.html","modified":1529239322214,"shasum":"b97a171c4b64b9ab0c284e0d2de91a058fb1308b"},{"_id":"public/archives/2016/index.html","modified":1529239322301,"shasum":"ffa88abb8ae4399f94b61f5405342f5ef0a44964"},{"_id":"public/archives/2016/01/index.html","modified":1529239322363,"shasum":"8259b69cee8a7cfe9644f536cddc338547df1f38"},{"_id":"public/archives/2016/02/index.html","modified":1529239322426,"shasum":"8fef0729db5c20f96783162cf6fd293847fa5229"},{"_id":"public/archives/2016/05/index.html","modified":1529239322489,"shasum":"cd2a94370165333ff9af9af856fc0734c2cd2a39"},{"_id":"public/archives/2016/06/index.html","modified":1529239322553,"shasum":"85505857008d6b9fe7ee91583bfdea2acde64792"},{"_id":"public/archives/2016/07/index.html","modified":1529239322606,"shasum":"a6e1476a9e9e4b719d46c4619ac37d7cf9c632e8"},{"_id":"public/archives/2016/08/index.html","modified":1529239322667,"shasum":"c6cd042794a2bff4b5ff8e66f463e905582ae015"},{"_id":"public/archives/2016/09/index.html","modified":1529239322729,"shasum":"2ab261fa7407ac90a22cc4eec38ceaebe74d9744"},{"_id":"public/archives/2017/index.html","modified":1529239322793,"shasum":"84eb7775a229775111f1b463a7a71000f5a1f5b2"},{"_id":"public/archives/2017/01/index.html","modified":1529239322847,"shasum":"26bd316277965541be0bf2e92a63802f4c0812f2"},{"_id":"public/archives/2017/02/index.html","modified":1529239322909,"shasum":"89692089a7969b0a5a7b0316aac0ed2b5770a37d"},{"_id":"public/archives/2018/index.html","modified":1529239322968,"shasum":"8a513736ef092c7e8c0476fc3b7796b88aa5ab79"},{"_id":"public/archives/2018/06/index.html","modified":1529239323028,"shasum":"8a513736ef092c7e8c0476fc3b7796b88aa5ab79"},{"_id":"public/categories/iOS/index.html","modified":1529239323085,"shasum":"02b2ac62c62d6c6921b30c1cbbf372caa3d0d001"},{"_id":"public/atom.xml","modified":1529239323088,"shasum":"0e20cd57046cff7fc4f44d487311cc46b0d21192"},{"_id":"public/index.html","modified":1529239323154,"shasum":"da9231e972289decbef1047c774bc4f9b1051ef9"},{"_id":"public/page/2/index.html","modified":1529239323214,"shasum":"a5cc13dc90ecc44ed02a472b1aaee81162ad7f42"},{"_id":"public/sitemap.xml","modified":1529239323216,"shasum":"8ff3fefda4956e39ca058d170c9e79824ed1a62c"},{"_id":"public/tags/XCTOOL/index.html","modified":1529239323278,"shasum":"8fef0729db5c20f96783162cf6fd293847fa5229"},{"_id":"public/tags/SHELL/index.html","modified":1529239323339,"shasum":"8fef0729db5c20f96783162cf6fd293847fa5229"},{"_id":"public/tags/LINUX命令/index.html","modified":1529239323396,"shasum":"8fef0729db5c20f96783162cf6fd293847fa5229"},{"_id":"public/tags/GIT/index.html","modified":1529239323457,"shasum":"89692089a7969b0a5a7b0316aac0ed2b5770a37d"},{"_id":"public/tags/Tool/index.html","modified":1529239323528,"shasum":"26bd316277965541be0bf2e92a63802f4c0812f2"},{"_id":"public/tags/YYKit/index.html","modified":1529239323609,"shasum":"1ef2891e3007646263e7a8e5606700e22c32098b"},{"_id":"public/tags/pthread/index.html","modified":1529239323681,"shasum":"85505857008d6b9fe7ee91583bfdea2acde64792"},{"_id":"public/tags/YYCache/index.html","modified":1529239323756,"shasum":"a6e1476a9e9e4b719d46c4619ac37d7cf9c632e8"},{"_id":"public/tags/SOCKET/index.html","modified":1529239323810,"shasum":"94b7690c02c39dcb7114d900f72a28dc3637b122"},{"_id":"public/tags/HTTP/index.html","modified":1529239323868,"shasum":"94b7690c02c39dcb7114d900f72a28dc3637b122"},{"_id":"public/tags/TCP/index.html","modified":1529239323927,"shasum":"94b7690c02c39dcb7114d900f72a28dc3637b122"},{"_id":"public/tags/UDP/index.html","modified":1529239323981,"shasum":"94b7690c02c39dcb7114d900f72a28dc3637b122"},{"_id":"public/tags/RSA加密/index.html","modified":1529239324042,"shasum":"4bfc8f19a032cd193ac91d80c1bd84220dfc0097"},{"_id":"public/tags/SHA签名/index.html","modified":1529239324099,"shasum":"4bfc8f19a032cd193ac91d80c1bd84220dfc0097"},{"_id":"public/tags/WWDC/index.html","modified":1529239324159,"shasum":"8a513736ef092c7e8c0476fc3b7796b88aa5ab79"}],"Category":[{"name":"iOS","_id":"cjiitluek000655cg4rjufc52"}],"Data":[],"Page":[{"title":"tags","date":"2016-01-16T06:00:56.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-01-16 14:00:56\ntype: \"tags\"\n---\n","updated":"2016-01-16T06:02:06.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjiitludt000055cgmo5jh4kx"},{"layout":"post","slug":"instagram","title":"相册","noDate":"true","_content":"\n<div class=\"instagram\" data-client-id=\"119e030b1722460e96852704153c0d16\" data-user-id=\"1260660358\">\n    <a href=\"http://instagram.com/panxianyue\" target=\"_blank\" class=\"open-ins\">图片来自instagram，正在加载中…</a>\n</div>\n<script src=\"/js/jquery.lazyload.js\"></script>\n<script src=\"/js/instagram.js\"></script>","source":"instagram/index.md","raw":"---\nlayout: post\nslug: \"instagram\"\ntitle: \"相册\"\nnoDate: \"true\"\n---\n\n<div class=\"instagram\" data-client-id=\"119e030b1722460e96852704153c0d16\" data-user-id=\"1260660358\">\n    <a href=\"http://instagram.com/panxianyue\" target=\"_blank\" class=\"open-ins\">图片来自instagram，正在加载中…</a>\n</div>\n<script src=\"/js/jquery.lazyload.js\"></script>\n<script src=\"/js/instagram.js\"></script>","date":"2016-04-17T02:43:09.000Z","updated":"2016-01-16T04:58:09.000Z","path":"instagram/index.html","comments":1,"_id":"cjiitludx000155cg0i4l4xpc"},{"title":"categories","date":"2016-01-16T06:02:26.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-01-16 14:02:26\ntype: \"categories\"\n---\n","updated":"2016-01-16T06:02:44.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjiitlue8000255cg71xliynj"},{"title":"about","date":"2016-01-16T06:07:17.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-01-16 14:07:17\n---\n","updated":"2016-01-16T06:07:17.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjiitlue9000355cg21z52two"}],"Post":[{"title":"执着","date":"2016-08-25T13:16:00.000Z","_content":"有些东西明明一文不值，却不舍得丢掉，<br>\n有时候找不着还会急得坐立不安。<br>\n问题是它们越来越旧，越来越老，而我已经渐渐不敢看它们。<br>\n它们装在盒子里，放在角落里，像一部部电影，<br>\n随时都能让我重新看到一场大雨，<br>\n一次分离，一杯咖啡，一个拥抱……<br>\n\n<!--more-->","source":"_posts/执着.md","raw":"---\ntitle: 执着\ndate: 2016-08-25 21:16:00\ntags:\n---\n有些东西明明一文不值，却不舍得丢掉，<br>\n有时候找不着还会急得坐立不安。<br>\n问题是它们越来越旧，越来越老，而我已经渐渐不敢看它们。<br>\n它们装在盒子里，放在角落里，像一部部电影，<br>\n随时都能让我重新看到一场大雨，<br>\n一次分离，一杯咖啡，一个拥抱……<br>\n\n<!--more-->","slug":"执着","published":1,"updated":"2017-01-03T04:28:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiitluec000455cgos0zoe3r"},{"title":"利用XCTool实现自动化打包","date":"2016-02-13T05:17:21.000Z","_content":"\n一个不会偷懒的程序员不是一个好程序员。每次编译打包都要花好长的时间，看了本篇博客后，就可以帮这些无聊的事情交给XCTool来做，我们喝喝茶，撩撩妹就行。\n<!--more-->\n\n\n# XCTool\n\nxctool是Facebook开源的一个命令行工具，用来代替苹果的xcodebuild工具。\n\n功能如下：\n\n* 像xcode一样能够编译程序\n* 编译的结果能够以结构化的形式输出\n* 编译内容输出彩色且方便阅读\n\n\n## 安装XCTool\n\n最简单的办法就是用homebrew安装xctool，这边就不介绍如何安装homebrew了。\n\n` brew install xctool`\n\n注：在用brew安装xctool的时候可能会出现can not install with HEAD error，当时尝试很多办法都没有搞定，像卸了重装... 终极解决方案：直接删除/usr/local里面里面所有的文件，*这边会导致你之前安装的一些插件会被删除，像CocoaPods*。\n\n## 编译\n\n`xctool -workspace ${project_path}/${project_name}.xcworkspace -scheme ${project_name} archive -archivePath ${project_path}/build/Debug-iphoneos/${project_name}_Debug.xcarchive -configuration ${build_Mode} || exit\n`\n \n# XcodeBuild\n\nshell里面会利用xcodebuild进行打包、清理工程\n\n## 打包\n`xcodebuild -exportArchive -archivePath ${project_path}/build/Debug-iphoneos/${project_name}_Debug.xcarchive -exportPath ${buildExportPath}/debug.ipa -exportFormat ipa \\\n-exportProvisioningProfile \"${profile_name}\" || exit`\n\n## 清理工程\n`xcodebuild clean -configuration ${build_Mode} || exit`\n\n\n# Linux命令\nshell里面会涉及到一些Linux命令：\n\n`echo \"输出内容\"`\n\n`echo '输出内容'`\n\n输出你想要输出的东西，*‘ ’表示要输出的内容为纯字符串，不可引用变量，“”表示输出的内容可包含变量*\n\n`cd ..`\n\n回退上一级目录\n\n`makdir`\n\n新建一个目录\n\n`rm -rf \"content\"`\n\n\n删除文件夹里面的所有内容\n\n**以上内容纯属虚构，若不感兴趣，完全可以跳过，直奔使用~**\n\n\n# 使用教程\n\n\n1. 将ipa_build这个文件夹移到和.xcodeproj或.xcworkspace同一级目录\n\n2. 打开build_debug或者build_release文件，替换profile_name字段，替换为你要打包项目的profile name\n\n3. 打开你的字段  `cd 脚本所在的目录` -> `chmod 777 build_debug.sh (仅第一次的时候需要)` -> `./build_debug.sh`\n\n4. 查看你的桌面即可以查看导出的IPA包\n\n<p>\n> 感谢大家花费时间来查看这篇blog，需要下载shell的同学请猛戳[Git](https://github.com/PanXianyue/ipa_build)。","source":"_posts/xctool-package.md","raw":"---\ntitle: 利用XCTool实现自动化打包\ndate: 2016-02-13 13:17:21\ncategories: iOS\ntags: [XCTOOL, SHELL, LINUX命令]\n---\n\n一个不会偷懒的程序员不是一个好程序员。每次编译打包都要花好长的时间，看了本篇博客后，就可以帮这些无聊的事情交给XCTool来做，我们喝喝茶，撩撩妹就行。\n<!--more-->\n\n\n# XCTool\n\nxctool是Facebook开源的一个命令行工具，用来代替苹果的xcodebuild工具。\n\n功能如下：\n\n* 像xcode一样能够编译程序\n* 编译的结果能够以结构化的形式输出\n* 编译内容输出彩色且方便阅读\n\n\n## 安装XCTool\n\n最简单的办法就是用homebrew安装xctool，这边就不介绍如何安装homebrew了。\n\n` brew install xctool`\n\n注：在用brew安装xctool的时候可能会出现can not install with HEAD error，当时尝试很多办法都没有搞定，像卸了重装... 终极解决方案：直接删除/usr/local里面里面所有的文件，*这边会导致你之前安装的一些插件会被删除，像CocoaPods*。\n\n## 编译\n\n`xctool -workspace ${project_path}/${project_name}.xcworkspace -scheme ${project_name} archive -archivePath ${project_path}/build/Debug-iphoneos/${project_name}_Debug.xcarchive -configuration ${build_Mode} || exit\n`\n \n# XcodeBuild\n\nshell里面会利用xcodebuild进行打包、清理工程\n\n## 打包\n`xcodebuild -exportArchive -archivePath ${project_path}/build/Debug-iphoneos/${project_name}_Debug.xcarchive -exportPath ${buildExportPath}/debug.ipa -exportFormat ipa \\\n-exportProvisioningProfile \"${profile_name}\" || exit`\n\n## 清理工程\n`xcodebuild clean -configuration ${build_Mode} || exit`\n\n\n# Linux命令\nshell里面会涉及到一些Linux命令：\n\n`echo \"输出内容\"`\n\n`echo '输出内容'`\n\n输出你想要输出的东西，*‘ ’表示要输出的内容为纯字符串，不可引用变量，“”表示输出的内容可包含变量*\n\n`cd ..`\n\n回退上一级目录\n\n`makdir`\n\n新建一个目录\n\n`rm -rf \"content\"`\n\n\n删除文件夹里面的所有内容\n\n**以上内容纯属虚构，若不感兴趣，完全可以跳过，直奔使用~**\n\n\n# 使用教程\n\n\n1. 将ipa_build这个文件夹移到和.xcodeproj或.xcworkspace同一级目录\n\n2. 打开build_debug或者build_release文件，替换profile_name字段，替换为你要打包项目的profile name\n\n3. 打开你的字段  `cd 脚本所在的目录` -> `chmod 777 build_debug.sh (仅第一次的时候需要)` -> `./build_debug.sh`\n\n4. 查看你的桌面即可以查看导出的IPA包\n\n<p>\n> 感谢大家花费时间来查看这篇blog，需要下载shell的同学请猛戳[Git](https://github.com/PanXianyue/ipa_build)。","slug":"xctool-package","published":1,"updated":"2017-01-03T04:28:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiitluei000555cg5w1v96dh"},{"title":"Sketch--makeicons","date":"2016-09-26T09:05:53.000Z","_content":"\n一枚不务正业的iOS工程师\n<!--more-->\n\n## makeiconswithsketch\n\n![](http://7xq5ax.com1.z0.glb.clouddn.com/sketch-symbol)\n\n\n<p>\n## 相关链接\n* **Sketch Toolbox**:http://sketchtoolbox.com/\n* **creativemarket**:https://creativemarket.com/\n* **Sketch中文手册**:http://www.sketchcn.com/sketch-chinese-user-manual.html\n* **dribbble**:https://dribbble.com/shots\n\n> 模仿[Allen朝辉](http://weibo.com/wangchaohui?from=myfollow_all&is_all=1#1474879197597)实现了一遍，So good！初学设计，有什么不足之处还望指导。\n> 资源放在[git](https://github.com/PanXianyue/BlogDemo/tree/master/Sketch)上，方便管理。","source":"_posts/sketch-makeicons.md","raw":"---\ntitle: Sketch--makeicons\ndate: 2016-09-26 17:05:53\ntags:\n---\n\n一枚不务正业的iOS工程师\n<!--more-->\n\n## makeiconswithsketch\n\n![](http://7xq5ax.com1.z0.glb.clouddn.com/sketch-symbol)\n\n\n<p>\n## 相关链接\n* **Sketch Toolbox**:http://sketchtoolbox.com/\n* **creativemarket**:https://creativemarket.com/\n* **Sketch中文手册**:http://www.sketchcn.com/sketch-chinese-user-manual.html\n* **dribbble**:https://dribbble.com/shots\n\n> 模仿[Allen朝辉](http://weibo.com/wangchaohui?from=myfollow_all&is_all=1#1474879197597)实现了一遍，So good！初学设计，有什么不足之处还望指导。\n> 资源放在[git](https://github.com/PanXianyue/BlogDemo/tree/master/Sketch)上，方便管理。","slug":"sketch-makeicons","published":1,"updated":"2017-01-03T04:28:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiitluep000e55cgl11awjvk"},{"title":"git命令","date":"2017-02-25T09:33:33.000Z","_content":"\n常用git命令梳理篇\n<!--more-->\n\n\n> 阮一峰这篇[常用命令清单][1]清晰的总结了常用的命令，这边我就不在赘述了，这边主要补充并整理个人的一些命令\n\n### 清单\n\n`$ git commit --amend -m [message]`\n \\# 使用一次新的commit，代替上一次的提交\n\\# **如果代码没有任何变化，则用来改写上一次commit的提交信息**\n\n`$ git commit --amend [file1] [file2] ...`\n \\# 重新做上次的commit， 并包括指定文件的新变化\n\n`$ git branch [branch] [commit]`\n\\# 新建一个分支，指向指定commit\n\n`$ git branch --set-upstream [branch] [remote-branch]`\n\\# 建立追踪关系，在现有分支与指定的远程分支之间\n\n`$ git cherry-pick [commit]`\n\\# 选择一个commit，合并进当前分支\n\n`$ git push -u [remote] [branch]`\n\\# 推送到remote仓库下的branch分支，并当前分支tracking到remote仓库下的branch分支\n\n`$ git push <remote> <local branch name>:<remote branch to push into>`\n\\# 上传本地的分支到远程的分支\n\n`$ git reflog/git log -g`\n\\# 查看所有的历史操作，这个命名比较实用。比如新来的同事经常误操作git导致不想发生的结果，这个时候你可以使用git reflog查看其进行的所有操作，然后进行reset\n\n### 常见问题\n\n- git每次要求你输入密码，Enter passphrase for key '/Users/XY/.ssh/id\\_rsa':？  \n\t直接敲`ssh-add`然后输入密码即可， 详情[点击][2]\n\n\n- git rebase 冲突?\n\t1. 解决一个补丁的应用冲突后，标记冲突已解决 git add -u\n\t2. 继续rebase   git rebase —continue\n\t3. push到远端就ok了，add后不需要commit\n\t4. git rebase —about 放弃rebase  \n\t\tgit rebase —skip   忽略本地冲突的补丁\n\n\n- git fetch 和 git pull 区别？  \n\tpull = fetch + merge，git pull 相当于 git fetch 加上一个git merge的操作  \n\tgit fetch 创建并更新所有远端分支的本地远端分支，创建远端分支时，会自动获取新加入的分支，这个操作并不会改变本地的工作区，详情[点击][3]\n\n- git revert 和 git reset 区别？  \n\trevert：通过创建一次新的 commit 来撤销一次 commit 所做出的修改。这种撤销的方式是安全的，因为它并不修改 commit history  \n\t  \n\treset：还原index的状态或者修改本地分支HEAD的位置。比如， 某个提交之后的代码都不要了，就可以在本地直接reset至指定的commit  \n\t补充：  \n\t `git reset --soft`  \n\t\\# staged snapshot 和 working directory 都未被改变  \n\t`git reset --mixed`  \n\t\\# staged snapshot 被更新， working directory 未被更改  \n\t`git reset --hard`  \n\t\\# staged snapshot 和 working directory 都将回退  \n\t这些标记经常和HEAD一起使用。例如，git reset --mixed HEAD可撤销所有缓存改动，但是保留他们在工作目录下。git reset --hard HEAD可彻底删除没有提交的改动  \n\n\n### 盗用一下😂  \n![][image-1]\n\n[1]:\thttp://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\n[2]:\thttp://unix.stackexchange.com/questions/12195/how-to-avoid-being-asked-passphrase-each-tim%E2%80%A6\n[3]:\thttp://stackoverflow.com/questions/292357/what-is-the-difference-between-git-pull-and-git-fetch\n\n[image-1]:\thttp://7xq5ax.com1.z0.glb.clouddn.com/e55477eejw1f07e4ffienj21cv2funfq.jpg","source":"_posts/git-commands.md","raw":"---\ntitle: git命令\ndate: 2017-02-25 17:33:33\ntags: [GIT]\n---\n\n常用git命令梳理篇\n<!--more-->\n\n\n> 阮一峰这篇[常用命令清单][1]清晰的总结了常用的命令，这边我就不在赘述了，这边主要补充并整理个人的一些命令\n\n### 清单\n\n`$ git commit --amend -m [message]`\n \\# 使用一次新的commit，代替上一次的提交\n\\# **如果代码没有任何变化，则用来改写上一次commit的提交信息**\n\n`$ git commit --amend [file1] [file2] ...`\n \\# 重新做上次的commit， 并包括指定文件的新变化\n\n`$ git branch [branch] [commit]`\n\\# 新建一个分支，指向指定commit\n\n`$ git branch --set-upstream [branch] [remote-branch]`\n\\# 建立追踪关系，在现有分支与指定的远程分支之间\n\n`$ git cherry-pick [commit]`\n\\# 选择一个commit，合并进当前分支\n\n`$ git push -u [remote] [branch]`\n\\# 推送到remote仓库下的branch分支，并当前分支tracking到remote仓库下的branch分支\n\n`$ git push <remote> <local branch name>:<remote branch to push into>`\n\\# 上传本地的分支到远程的分支\n\n`$ git reflog/git log -g`\n\\# 查看所有的历史操作，这个命名比较实用。比如新来的同事经常误操作git导致不想发生的结果，这个时候你可以使用git reflog查看其进行的所有操作，然后进行reset\n\n### 常见问题\n\n- git每次要求你输入密码，Enter passphrase for key '/Users/XY/.ssh/id\\_rsa':？  \n\t直接敲`ssh-add`然后输入密码即可， 详情[点击][2]\n\n\n- git rebase 冲突?\n\t1. 解决一个补丁的应用冲突后，标记冲突已解决 git add -u\n\t2. 继续rebase   git rebase —continue\n\t3. push到远端就ok了，add后不需要commit\n\t4. git rebase —about 放弃rebase  \n\t\tgit rebase —skip   忽略本地冲突的补丁\n\n\n- git fetch 和 git pull 区别？  \n\tpull = fetch + merge，git pull 相当于 git fetch 加上一个git merge的操作  \n\tgit fetch 创建并更新所有远端分支的本地远端分支，创建远端分支时，会自动获取新加入的分支，这个操作并不会改变本地的工作区，详情[点击][3]\n\n- git revert 和 git reset 区别？  \n\trevert：通过创建一次新的 commit 来撤销一次 commit 所做出的修改。这种撤销的方式是安全的，因为它并不修改 commit history  \n\t  \n\treset：还原index的状态或者修改本地分支HEAD的位置。比如， 某个提交之后的代码都不要了，就可以在本地直接reset至指定的commit  \n\t补充：  \n\t `git reset --soft`  \n\t\\# staged snapshot 和 working directory 都未被改变  \n\t`git reset --mixed`  \n\t\\# staged snapshot 被更新， working directory 未被更改  \n\t`git reset --hard`  \n\t\\# staged snapshot 和 working directory 都将回退  \n\t这些标记经常和HEAD一起使用。例如，git reset --mixed HEAD可撤销所有缓存改动，但是保留他们在工作目录下。git reset --hard HEAD可彻底删除没有提交的改动  \n\n\n### 盗用一下😂  \n![][image-1]\n\n[1]:\thttp://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\n[2]:\thttp://unix.stackexchange.com/questions/12195/how-to-avoid-being-asked-passphrase-each-tim%E2%80%A6\n[3]:\thttp://stackoverflow.com/questions/292357/what-is-the-difference-between-git-pull-and-git-fetch\n\n[image-1]:\thttp://7xq5ax.com1.z0.glb.clouddn.com/e55477eejw1f07e4ffienj21cv2funfq.jpg","slug":"git-commands","published":1,"updated":"2017-03-08T14:12:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiitlues000f55cg9a2ws6i4"},{"title":"Alfred","date":"2017-01-03T04:30:11.000Z","_content":"\n一款你用上就爱不释手的软件\n<!--more-->\n\n\n## 常用命令\n\n`open` : 关键字用来打开文件或者文件夹 \n`find` : 关键字用来查询文件或者文件夹的位置 \n`in` : 关键字用来查找文本文件内含有查询文字的文件（这个功能很强大啊） \n`tags` :关键字用来查询含有查询tags的文件或者文件夹 \n\n![][image-1]\n`/` : 来直接定位到根目录或者使用 \n`~` : 来直接定位到当前用户的home目录 \n**在文件定位工具中我们可以设置是否使用左右建来作为前进或者后退功能 **\n\n`screensaver` : 屏幕保护程序\n`trash` : 显示回收站\n`emptytrash` : 清空回收站\n`logout` : 登出\n`sleep` : 睡眠\n`lock` : 锁定\n`restart` : 重启\n`shutdown` : 关机\n`hide ` : 隐藏\n`quit ` : 关闭\n`forcequit ` : 强制关闭\n`quitall ` : 关闭所有应用程序 \n`>` : 关键字和使用的默认控制台程序 \n`di` : 关键字来查询中英字典 \n\n### Quick Search\n![][image-2]\n\n启用了Quick Search选项后我们可以使用’单引号或者space空格快速启用打开文件或者文件夹功能类似于使用open关键字\n\n### Buffer\n![][image-3]\n这个功能非常的实用，个人表示很喜欢，能够很大程度的提高效率。将查找到的文件或者文件夹加入到缓存中，然后就可以对搜索到的结果做批量处理了。这里的设置也很简单主要就是是否启用缓存功能和缓存功能的几个快捷键，并且可以设置使用完后是否清空缓存等设置。 \n\n![][image-4]\n**通过option键 + ⬆️来将选中的文件夹或者文件加入到缓存，我们可以看到如果存在缓存的话Alfred搜索界面上会出现选中文件的小图标**\n\n![][image-5]\n**通过option键 + ➡️来批量处理缓存中的文件夹和文件。我们可以打开、发邮件、拷贝、移动、删除（是不是感觉到这个功能就是代替鼠标选中文件然后右键的功能 )**\n\n\n### 1Password\n使用1p关键字来查询密码库 \n![][image-6]\n\n![][image-7]\n\n> 很容易忘记，索性就将笔记整理成blog了。后续有时间再进行扩展，不足之处还望见谅。\n\n\n\n[image-1]:\thttp://7xq5ax.com1.z0.glb.clouddn.com/alfread-1.png\n[image-2]:\thttp://7xq5ax.com1.z0.glb.clouddn.com/Alfred-Quick%20Search.png\n[image-3]:\thttp://7xq5ax.com1.z0.glb.clouddn.com/Alfred-buffer.png\n[image-4]:\thttp://7xq5ax.com1.z0.glb.clouddn.com/Alfred-search.png\n[image-5]:\thttp://7xq5ax.com1.z0.glb.clouddn.com/Alfred-buffer2.png\n[image-6]:\thttp://7xq5ax.com1.z0.glb.clouddn.com/Alfred-1p.png\n[image-7]:\thttp://7xq5ax.com1.z0.glb.clouddn.com/Alfred-1p-search.png","source":"_posts/alfred-use.md","raw":"\n---\ntitle: Alfred\ndate: 2017-01-03 12:30:11\ntags: [Tool]\n---\n\n一款你用上就爱不释手的软件\n<!--more-->\n\n\n## 常用命令\n\n`open` : 关键字用来打开文件或者文件夹 \n`find` : 关键字用来查询文件或者文件夹的位置 \n`in` : 关键字用来查找文本文件内含有查询文字的文件（这个功能很强大啊） \n`tags` :关键字用来查询含有查询tags的文件或者文件夹 \n\n![][image-1]\n`/` : 来直接定位到根目录或者使用 \n`~` : 来直接定位到当前用户的home目录 \n**在文件定位工具中我们可以设置是否使用左右建来作为前进或者后退功能 **\n\n`screensaver` : 屏幕保护程序\n`trash` : 显示回收站\n`emptytrash` : 清空回收站\n`logout` : 登出\n`sleep` : 睡眠\n`lock` : 锁定\n`restart` : 重启\n`shutdown` : 关机\n`hide ` : 隐藏\n`quit ` : 关闭\n`forcequit ` : 强制关闭\n`quitall ` : 关闭所有应用程序 \n`>` : 关键字和使用的默认控制台程序 \n`di` : 关键字来查询中英字典 \n\n### Quick Search\n![][image-2]\n\n启用了Quick Search选项后我们可以使用’单引号或者space空格快速启用打开文件或者文件夹功能类似于使用open关键字\n\n### Buffer\n![][image-3]\n这个功能非常的实用，个人表示很喜欢，能够很大程度的提高效率。将查找到的文件或者文件夹加入到缓存中，然后就可以对搜索到的结果做批量处理了。这里的设置也很简单主要就是是否启用缓存功能和缓存功能的几个快捷键，并且可以设置使用完后是否清空缓存等设置。 \n\n![][image-4]\n**通过option键 + ⬆️来将选中的文件夹或者文件加入到缓存，我们可以看到如果存在缓存的话Alfred搜索界面上会出现选中文件的小图标**\n\n![][image-5]\n**通过option键 + ➡️来批量处理缓存中的文件夹和文件。我们可以打开、发邮件、拷贝、移动、删除（是不是感觉到这个功能就是代替鼠标选中文件然后右键的功能 )**\n\n\n### 1Password\n使用1p关键字来查询密码库 \n![][image-6]\n\n![][image-7]\n\n> 很容易忘记，索性就将笔记整理成blog了。后续有时间再进行扩展，不足之处还望见谅。\n\n\n\n[image-1]:\thttp://7xq5ax.com1.z0.glb.clouddn.com/alfread-1.png\n[image-2]:\thttp://7xq5ax.com1.z0.glb.clouddn.com/Alfred-Quick%20Search.png\n[image-3]:\thttp://7xq5ax.com1.z0.glb.clouddn.com/Alfred-buffer.png\n[image-4]:\thttp://7xq5ax.com1.z0.glb.clouddn.com/Alfred-search.png\n[image-5]:\thttp://7xq5ax.com1.z0.glb.clouddn.com/Alfred-buffer2.png\n[image-6]:\thttp://7xq5ax.com1.z0.glb.clouddn.com/Alfred-1p.png\n[image-7]:\thttp://7xq5ax.com1.z0.glb.clouddn.com/Alfred-1p-search.png","slug":"alfred-use","published":1,"updated":"2017-01-03T10:50:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiitluev000i55cghs04ml91"},{"title":"YYKit源码分析---pthread","date":"2016-06-21T09:43:18.000Z","_content":"\n大家都知道ibireme的[YYKit](https://github.com/ibireme/YYKit)很强大，个人也特别佩服ibireme。大神常常教导我们这样的小白说：多读源码能够大幅度的提高功力。 <p>每当项目上线后，需求还没有下来时，都会有一段闲暇时间。这段时间学习是极佳的。YYKit这个框架刚开始看的时候就遇到pthread这个玩意，之前很少接触。在此，记录自己的所学所得，并分享给大家。\n<!--more-->\n\n\n## 先来看下YY定义的宏\n```\nstatic inline void pthread_mutex_init_recursive(pthread_mutex_t *mutex, bool recursive) {\n#define YYMUTEX_ASSERT_ON_ERROR(x_) do { \\\n__unused volatile int res = (x_); \\\nassert(res == 0); \\\n} while (0)\n    assert(mutex != NULL);\n    if (!recursive) {\n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutex_init(mutex, NULL));\n    } else {\n        pthread_mutexattr_t attr;\n        \n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutexattr_init (&attr));\n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE));\n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutex_init (mutex, &attr));\n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutexattr_destroy (&attr));\n    }\n#undef YYMUTEX_ASSERT_ON_ERROR\n}   \n```\n大神的代码都是晦涩难懂的，看到这段代码后劳资突然产生了好几个问题：\n\n- 这个方法是用来干嘛的呢？\n- pthread_mutex_t是什么鬼？\n- pthread_mutexattr_t是用来配置pthread_mutex_t的吗？\n\n## 解读\n#### 功能\n其实就是创建个互斥线程，并没有想象中的可怕\n#### pthread_mutex_t\n`int pthread_mutex_init(pthread_mutex_t * __restrict,\n\t\tconst pthread_mutexattr_t * __restrict);` 是用这个函数创建出来的。函数是以动态的方式创建互斥锁的，参数attr指定了新建互斥锁的属性。<br>`recursive`这个`bool`值为false时，attr为空，则使用默认的互斥锁属性，默认属性为快速互斥锁。<br>`recursive`这个`bool`值为true时，配置互斥锁属性创建相应的互斥锁。\n#### YYMUTEX_ASSERT_ON_ERROR\n断言来进行检查错误，所有操作返回非0时，表示有异常错误发生\n#### Mutex type attributes\n**PTHREAD_MUTEX_NORMAL**：不进行deadlock detection（死锁检测）。当进行relock时，这个mutex就导致deadlock。对一个没有进行lock或者已经unlock的对象进行unlock操作，结果也是未知的。<br>**PTHREAD_MUTEX_ERRORCHECK**：和PTHREAD_MUTEX_NORMAL相比，PTHREAD_MUTEX_ERRORCHECK会进行错误检测，以上错误行为都会返回一个错误。<br>**PTHREAD_MUTEX_RECURSIVE**：和semaphore（信号量）有个类似的东西，mutex会有个锁住次数的概念，第一次锁住mutex的时候，锁住次数设置为1，每一次一个线程unlock这个mutex时，锁住次数就会减1。当锁住次数为0时，其他线程就可以获得该mutex锁了。同样，对一个没有进行lock或者已经unlock的对象进行unlock操作，将返回一个错误。<br>**PTHREAD_MUTEX_DEFAULT**：默认PTHREAD_MUTEX_NORMAL。\n\n## 再看看YY如何使用该宏\n```\n- (YYImageFrame *)frameAtIndex:(NSUInteger)index decodeForDisplay:(BOOL)decodeForDisplay {\n    YYImageFrame *result = nil;\n    pthread_mutex_lock(&_lock);\n    result = [self _frameAtIndex:index decodeForDisplay:decodeForDisplay];\n    pthread_mutex_unlock(&_lock);\n    return result;\n}\n```\n**这边为了防止多线程资源抢夺的问题，先进行lock下，等数据操作完毕后释放unlock，有没有一种豁然开朗的感觉呢<br>平时我们在多线程操作的时候也可以使用NSLock、synchronized来进行加锁，yy使用了更加偏向底层的pthread**\n\n## pthread_t和NSThread\n两者都是用来操作线程的对象，平时我们使用上层的NSThread比较多，像[NSThread mainThread]获取主线程，[NSThread currentThread] 获取当前线程。pthread_t和NSThread是一一对应的，同样可以通过pthread_main_thread_np() 、pthread_self()来获取。NSThread只是对pthread_t的一层封装而已。\n\n## 实战\n- 声明函数\n\n```\nvoid *func(void *argu) {\n    char *m = (char *)argu;\n\n    pthread_mutex_lock(&mutex);\n    while (*m != '\\0') {\n        printf(\"%c\", *m);\n        fflush(stdout);\n        sleep(3);\n        m++;\n    }\n    printf(\"\\n\");\n    pthread_mutex_unlock(&mutex);\n    return 0;\n}\n```\n\n- mutex使用 \n\n```\n    int rc1, rc2;\n    \n    char *str1 = \"Hi\";\n    char *str2 = \"Boy!\";\n    \n    pthread_t thread1, thread2;\n    pthread_mutex_init(&mutex, NULL);\n\n    if ((rc1 = pthread_create(&thread1, NULL, func, str1))) {\n        fprintf(stdout, \"thread1 creat fail : %d \\n!\", rc1);\n    }\n    if ((rc2 = pthread_create(&thread2, NULL, func, str2))) {\n        fprintf(stdout, \"thread2 creat fail : %d \\n!\", rc2);\n    }\n\n    // https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man3/pthread_join.3.html#//apple_ref/c/func/pthread_join\n    // 等待一个线程的结束，当函数返回时，被等待的线程资源被收回。若线程已经被收回，那么该函数会立即返回\n    pthread_join(thread1, NULL);\n    pthread_join(thread2, NULL);\n\n\tprintf(\"这边只有线程被回收后才会执行！\");\n```\n- 可以帮pthread_mutex_lock(&mutex)和pthread_mutex_unlock(&mutex)注释掉看下打印<p>\n\n> 感谢大家花费时间来查看这篇blog，需要下载demo的同学请猛戳[Git](https://github.com/PanXianyue/BlogDemo)。","source":"_posts/YYKit-pthread.md","raw":"---\ntitle: YYKit源码分析---pthread\ndate: 2016-06-21 17:43:18\ncategories: iOS\ntags: [YYKit, pthread]\n---\n\n大家都知道ibireme的[YYKit](https://github.com/ibireme/YYKit)很强大，个人也特别佩服ibireme。大神常常教导我们这样的小白说：多读源码能够大幅度的提高功力。 <p>每当项目上线后，需求还没有下来时，都会有一段闲暇时间。这段时间学习是极佳的。YYKit这个框架刚开始看的时候就遇到pthread这个玩意，之前很少接触。在此，记录自己的所学所得，并分享给大家。\n<!--more-->\n\n\n## 先来看下YY定义的宏\n```\nstatic inline void pthread_mutex_init_recursive(pthread_mutex_t *mutex, bool recursive) {\n#define YYMUTEX_ASSERT_ON_ERROR(x_) do { \\\n__unused volatile int res = (x_); \\\nassert(res == 0); \\\n} while (0)\n    assert(mutex != NULL);\n    if (!recursive) {\n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutex_init(mutex, NULL));\n    } else {\n        pthread_mutexattr_t attr;\n        \n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutexattr_init (&attr));\n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE));\n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutex_init (mutex, &attr));\n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutexattr_destroy (&attr));\n    }\n#undef YYMUTEX_ASSERT_ON_ERROR\n}   \n```\n大神的代码都是晦涩难懂的，看到这段代码后劳资突然产生了好几个问题：\n\n- 这个方法是用来干嘛的呢？\n- pthread_mutex_t是什么鬼？\n- pthread_mutexattr_t是用来配置pthread_mutex_t的吗？\n\n## 解读\n#### 功能\n其实就是创建个互斥线程，并没有想象中的可怕\n#### pthread_mutex_t\n`int pthread_mutex_init(pthread_mutex_t * __restrict,\n\t\tconst pthread_mutexattr_t * __restrict);` 是用这个函数创建出来的。函数是以动态的方式创建互斥锁的，参数attr指定了新建互斥锁的属性。<br>`recursive`这个`bool`值为false时，attr为空，则使用默认的互斥锁属性，默认属性为快速互斥锁。<br>`recursive`这个`bool`值为true时，配置互斥锁属性创建相应的互斥锁。\n#### YYMUTEX_ASSERT_ON_ERROR\n断言来进行检查错误，所有操作返回非0时，表示有异常错误发生\n#### Mutex type attributes\n**PTHREAD_MUTEX_NORMAL**：不进行deadlock detection（死锁检测）。当进行relock时，这个mutex就导致deadlock。对一个没有进行lock或者已经unlock的对象进行unlock操作，结果也是未知的。<br>**PTHREAD_MUTEX_ERRORCHECK**：和PTHREAD_MUTEX_NORMAL相比，PTHREAD_MUTEX_ERRORCHECK会进行错误检测，以上错误行为都会返回一个错误。<br>**PTHREAD_MUTEX_RECURSIVE**：和semaphore（信号量）有个类似的东西，mutex会有个锁住次数的概念，第一次锁住mutex的时候，锁住次数设置为1，每一次一个线程unlock这个mutex时，锁住次数就会减1。当锁住次数为0时，其他线程就可以获得该mutex锁了。同样，对一个没有进行lock或者已经unlock的对象进行unlock操作，将返回一个错误。<br>**PTHREAD_MUTEX_DEFAULT**：默认PTHREAD_MUTEX_NORMAL。\n\n## 再看看YY如何使用该宏\n```\n- (YYImageFrame *)frameAtIndex:(NSUInteger)index decodeForDisplay:(BOOL)decodeForDisplay {\n    YYImageFrame *result = nil;\n    pthread_mutex_lock(&_lock);\n    result = [self _frameAtIndex:index decodeForDisplay:decodeForDisplay];\n    pthread_mutex_unlock(&_lock);\n    return result;\n}\n```\n**这边为了防止多线程资源抢夺的问题，先进行lock下，等数据操作完毕后释放unlock，有没有一种豁然开朗的感觉呢<br>平时我们在多线程操作的时候也可以使用NSLock、synchronized来进行加锁，yy使用了更加偏向底层的pthread**\n\n## pthread_t和NSThread\n两者都是用来操作线程的对象，平时我们使用上层的NSThread比较多，像[NSThread mainThread]获取主线程，[NSThread currentThread] 获取当前线程。pthread_t和NSThread是一一对应的，同样可以通过pthread_main_thread_np() 、pthread_self()来获取。NSThread只是对pthread_t的一层封装而已。\n\n## 实战\n- 声明函数\n\n```\nvoid *func(void *argu) {\n    char *m = (char *)argu;\n\n    pthread_mutex_lock(&mutex);\n    while (*m != '\\0') {\n        printf(\"%c\", *m);\n        fflush(stdout);\n        sleep(3);\n        m++;\n    }\n    printf(\"\\n\");\n    pthread_mutex_unlock(&mutex);\n    return 0;\n}\n```\n\n- mutex使用 \n\n```\n    int rc1, rc2;\n    \n    char *str1 = \"Hi\";\n    char *str2 = \"Boy!\";\n    \n    pthread_t thread1, thread2;\n    pthread_mutex_init(&mutex, NULL);\n\n    if ((rc1 = pthread_create(&thread1, NULL, func, str1))) {\n        fprintf(stdout, \"thread1 creat fail : %d \\n!\", rc1);\n    }\n    if ((rc2 = pthread_create(&thread2, NULL, func, str2))) {\n        fprintf(stdout, \"thread2 creat fail : %d \\n!\", rc2);\n    }\n\n    // https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man3/pthread_join.3.html#//apple_ref/c/func/pthread_join\n    // 等待一个线程的结束，当函数返回时，被等待的线程资源被收回。若线程已经被收回，那么该函数会立即返回\n    pthread_join(thread1, NULL);\n    pthread_join(thread2, NULL);\n\n\tprintf(\"这边只有线程被回收后才会执行！\");\n```\n- 可以帮pthread_mutex_lock(&mutex)和pthread_mutex_unlock(&mutex)注释掉看下打印<p>\n\n> 感谢大家花费时间来查看这篇blog，需要下载demo的同学请猛戳[Git](https://github.com/PanXianyue/BlogDemo)。","slug":"YYKit-pthread","published":1,"updated":"2017-01-03T04:28:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiitluey000l55cg71u0ckei"},{"title":"YYKit源码分析---YYCache","date":"2016-07-18T14:47:35.000Z","_content":"[YYCache](https://github.com/ibireme/YYCache)是用于Objective-C中用于缓存的第三方框架。此文主要用来讲解该框架的实现细节，性能分析、设计思路ibireme已经讲得很清楚了，我这边就不在分析了。\n\n<!--more-->\n\n## 文件结构\n![](http://7xq5ax.com1.z0.glb.clouddn.com/yycache-tree.png)\n1. YYCache：同时实现内存缓存和磁盘缓存且是线程安全的\n2. YYMemoryCache：实现内存缓存，所有的API都是线程安全的，与其他缓存方式比较不同的是内部利用LRU淘汰算法（后面会介绍）来提高性能\n3. YYDiskCache：实现磁盘缓存，所有的API都是线程安全的，内部也采用了LRU淘汰算法，主要SQLite和文件存储两种方式\n4. YYKVStorage：实现磁盘存储，不推荐直接使用该类，该类不是线程安全的\n\n## LRU\nLRU(Least recently used，最近最少使用)算法，根据访问的历史记录来对数据进行淘汰\n<p>\n![](http://7xq5ax.com1.z0.glb.clouddn.com/lru.png)\n<p>\n简单的来说3点：\n\n1. 有新数据加入时添加到链表的头部\n2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部\n3. 当链表满的时候，将链表尾部的数据丢弃\n\n**在YYMemoryCache中使用来双向链表和NSDictionary实现了LRU淘汰算法，后面会介绍**\n\n## 关于锁\nYYCache 使用到两种锁\n\n1. OSSpinLock ：自旋锁，上一篇博客也提及到[pthread_mutex](http://iipanda.com/2016/06/21/YYKit-pthread/) \n2. dispatch_semaphore：信号量，当信号量为1的时候充当锁来用\n\n**内存缓存用的pthread_mutex：由于pthread_mutex相当于do while忙等，等待时会消耗大量的CPU资源<br>磁盘缓存使用的dispatch_semaphore：优势在于等待时不会消耗CPU资源**\n> 简单的科普就到这，现在来开始源码的探索\n\n## _YYLinkedMap\n```\n@interface _YYLinkedMapNode : NSObject {\n    @package\n    __unsafe_unretained _YYLinkedMapNode *_prev; // retained by dic\n    __unsafe_unretained _YYLinkedMapNode *_next; // retained by dic\n    id _key;\n    id _value;\n    NSUInteger _cost;\n    NSTimeInterval _time;\n}\n@end\n```\n**_YYLinkedMapNode**：链表的节点<br>\n\\_prev、\\_next：分别表示指向上一个节点、下一个节点<br>\n\\_key：缓存的key<br>\n\\_value：缓存对象<br>\n\\_cost：内存消耗<br>\n\\_time：缓存时间<br>\n\n```\n@interface _YYLinkedMap : NSObject {\n    @package\n    CFMutableDictionaryRef _dic; // do not set object directly\n    NSUInteger _totalCost;\n    NSUInteger _totalCount;\n    _YYLinkedMapNode *_head; // MRU（最近最常使用算法）, do not change it directly\n    _YYLinkedMapNode *_tail; // LRU（最近最少使用算法-清除较不常使用数据）, do not change it directly\n    BOOL _releaseOnMainThread;\n    BOOL _releaseAsynchronously;\n}\n\n```\n**_YYLinkedMap**：链表<br>\n\\_dic：用来保存节点<br>\n\\_totalCost：总缓存开销<br>\n\\_head、\\_tail：头节点、尾节点<br>\n\\_releaseOnMainThread：是否在主线程释放\\_YYLinkedMapNode<br>\n\\_releaseAsynchronously：是否异步释放\\_YYLinkedMapNode<br>\n\n\n**双向链表**<br>\n![](http://7xq5ax.com1.z0.glb.clouddn.com/LinkedMap@1x.png)\n\n1. 插入节点到头部\n2. 将除两边的节点移到头部\n3. 移除除两边的节点\n4. 移除尾部节点\n5. 移除所有节点\n\n看下移除所有节点的代码：\n\n```\n- (void)removeAll {\n    _totalCost = 0;\n    _totalCount = 0;\n    _head = nil;\n    _tail = nil;\n    if (CFDictionaryGetCount(_dic) > 0) {\n        CFMutableDictionaryRef holder = _dic;\n        _dic = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n        \n        if (_releaseAsynchronously) {\n            dispatch_queue_t queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();\n            dispatch_async(queue, ^{\n                CFRelease(holder); // hold and release in specified queue\n            });\n        } else if (_releaseOnMainThread && !pthread_main_np()) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                CFRelease(holder); // hold and release in specified queue\n            });\n        } else {\n            CFRelease(holder);\n        }\n    }\n}\n\n\n```\n\n\n\n这边通过双向链表来对数据进行操作，和NSDictionary实现了LRU淘汰算法。时间复杂度0（1），5种操作基本上都是对头尾节点和链表节点的上一个节点和下一个节点进行操作。\n\n\n## YYMemoryCache\n这边介绍两个主要的操作：添加缓存，查找缓存<p>\n\n- **添加缓存**\n\n```\n- (void)setObject:(id)object forKey:(id)key withCost:(NSUInteger)cost {\n    if (!key) return;\n    if (!object) {\n        // 缓存对象为nil，直接移除\n        [self removeObjectForKey:key];\n        return;\n    }\n    // 为了保证线程安全，数据操作前进行加锁\n    pthread_mutex_lock(&_lock);\n    // 查找缓存\n    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru->_dic, (__bridge const void *)(key));\n    // 当前时间\n    NSTimeInterval now = CACurrentMediaTime();\n    if (node) {\n        // 缓存对象已存在，更新数据，并移到栈顶\n        _lru->_totalCost -= node->_cost;\n        _lru->_totalCost += cost;\n        node->_cost = cost;\n        node->_time = now;\n        node->_value = object;\n        [_lru bringNodeToHead:node];\n    } else {\n        // 缓存对象不存在，添加数据，并移到栈顶\n        node = [_YYLinkedMapNode new];\n        node->_cost = cost;\n        node->_time = now;\n        node->_key = key;\n        node->_value = object;\n        [_lru insertNodeAtHead:node];\n    }\n    // 判断当前的缓存进行是否超出了设定值，若超出则进行整理\n    if (_lru->_totalCost > _costLimit) {\n        dispatch_async(_queue, ^{\n            [self trimToCost:_costLimit];\n        });\n    }\n    \n    // 每次添加数据仅有一个，数量上超出时，直接移除尾部那个object即可\n    if (_lru->_totalCount > _countLimit) {\n        _YYLinkedMapNode *node = [_lru removeTailNode];\n        if (_lru->_releaseAsynchronously) {\n            dispatch_queue_t queue = _lru->_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();\n            dispatch_async(queue, ^{\n                [node class]; //hold and release in queue\n            });\n        } else if (_lru->_releaseOnMainThread && !pthread_main_np()) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [node class]; //hold and release in queue\n            });\n        }\n    }\n    // 操作结束，解锁\n    pthread_mutex_unlock(&_lock);\n}\n\n```\n\n- **异步线程释放**\n![](http://7xq5ax.com1.z0.glb.clouddn.com/%E5%BC%82%E6%AD%A5%E9%87%8A%E6%94%BE.png)\n里面很多都用到类似的方法，将一个对象在异步线程中释放，来分析下：<br>\n\n\n\t\t- p\n\t\t1. 首先通过node来对其进行持有，以至于不会在方法调用结束的时候被销毁\n\t\t2. 我要要在其他线程中进行销毁，所以将销毁操作放在block中，block就会对其进行持有\n\t\t3. 这边在block中随便调用了个方法，保证编译器不会优化掉这个操作\n\t\t4. 当block结束后，node没有被持有的时候，就会在当前线程被release掉了\n\n\n\n- **添加缓存**\n\n```\n// 这边从memory中取数据时，根据LRU原则，将最新取出的object放到栈头\n- (id)objectForKey:(id)key {\n    if (!key) return nil;\n    pthread_mutex_lock(&_lock);\n    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru->_dic, (__bridge const void *)(key));\n    if (node) {\n        node->_time = CACurrentMediaTime();\n        [_lru bringNodeToHead:node];\n    }\n    pthread_mutex_unlock(&_lock);\n    return node ? node->_value : nil;\n}\n\n```\n\n## YYKVStorage\n\n该文件主要以两种方式来实现磁盘存储：SQLite、File，使用两种方式混合进行存储主要为了提高读写效率。写入数据时，SQLite要比文件的方式更快；读取数据的速度主要取决于文件的大小。据测试，在iPhone6中，当文件大小超过20kb时，File要比SQLite快的多。所以当大文件存储时建议用File的方式，小文件更适合用SQLite。<p>\n下边分别对Save、Remove、Get分别进行分析\n\n\n- **Save**\n\n```\n- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(NSString *)filename extendedData:(NSData *)extendedData {\n    // 条件不符合\n    if (key.length == 0 || value.length == 0) return NO;\n    if (_type == YYKVStorageTypeFile && filename.length == 0) {\n        return NO;\n    }\n    \n    if (filename.length) {    // filename存在 SQLite File两种方式并行\n        // 用文件进行存储\n        if (![self _fileWriteWithName:filename data:value]) {\n            return NO;\n        }\n        // 用SQLite进行存储\n        if (![self _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) {\n            // 当使用SQLite方式存储失败时，删除本地文件存储\n            [self _fileDeleteWithName:filename];\n            return NO;\n        }\n        return YES;\n    } else {               // filename不存在 SQLite\n        if (_type != YYKVStorageTypeSQLite) {\n            // 这边去到filename后，删除filename对应的file文件\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            if (filename) {\n                [self _fileDeleteWithName:filename];\n            }\n        }\n        // SQLite 进行存储\n        return [self _dbSaveWithKey:key value:value fileName:nil extendedData:extendedData];\n    }\n}\n\n\n```\n\n- **Remove**\n\n```\n- (BOOL)removeItemForKey:(NSString *)key {\n    if (key.length == 0) return NO;\n    switch (_type) {\n        case YYKVStorageTypeSQLite: {\n            // 删除SQLite文件\n            return [self _dbDeleteItemWithKey:key];\n        } break;\n        case YYKVStorageTypeFile:\n        case YYKVStorageTypeMixed: {\n            // 获取filename\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            if (filename) {\n                // 删除filename对的file\n                [self _fileDeleteWithName:filename];\n            }\n            // 删除SQLite文件\n            return [self _dbDeleteItemWithKey:key];\n        } break;\n        default: return NO;\n    }\n}\n\n```\n\n- **Get**\n\n```\n- (NSData *)getItemValueForKey:(NSString *)key {\n    if (key.length == 0) return nil;\n    NSData *value = nil;\n    switch (_type) {\n        case YYKVStorageTypeFile: { //File\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            if (filename) {\n                // 根据filename获取File\n                value = [self _fileReadWithName:filename];\n                if (!value) {\n                    // 当value不存在，用对应的key删除SQLite文件\n                    [self _dbDeleteItemWithKey:key];\n                    value = nil;\n                }\n            }\n        } break;\n        case YYKVStorageTypeSQLite: {\n            // SQLite 方式获取\n            value = [self _dbGetValueWithKey:key];\n        } break;\n        case YYKVStorageTypeMixed: {\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            // filename 存在文件获取，不存在SQLite方式获取\n            if (filename) {\n                value = [self _fileReadWithName:filename];\n                if (!value) {\n                    [self _dbDeleteItemWithKey:key];\n                    value = nil;\n                }\n            } else {\n                value = [self _dbGetValueWithKey:key];\n            }\n        } break;\n    }\n    if (value) {\n        // 更新文件操作时间\n        [self _dbUpdateAccessTimeWithKey:key];\n    }\n    return value;\n}\n\n```\n\nFile方式主要使用的writeToFile进行存储，SQLte直接使用的sqlite3来对文件进行操作，具体数据库相关的操作这边就不在进行分析了，感兴趣的自己可以阅读下\n\n## YYDiskCache\n\nYYDiskCache是对YYKVStorage进行的一次封装，是线程安全的，这边使用的是dispatch_semaphore_signal来确保线程的安全。另外他结合LRU算法，根据文件的大小自动选择存储方式来达到更好的性能。\n\n```\n- (instancetype)initWithPath:(NSString *)path\n             inlineThreshold:(NSUInteger)threshold {\n    self = [super init];\n    if (!self) return nil;\n    \n    // 获取缓存的 YYDiskCache\n    YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);\n    if (globalCache) return globalCache;\n    \n    // 确定存储的方式\n    YYKVStorageType type;\n    if (threshold == 0) {\n        type = YYKVStorageTypeFile;\n    } else if (threshold == NSUIntegerMax) {\n        type = YYKVStorageTypeSQLite;\n    } else {\n        type = YYKVStorageTypeMixed;\n    }\n    \n    // 初始化 YYKVStorage\n    YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type];\n    if (!kv) return nil;\n    \n    // 初始化数据\n    _kv = kv;\n    _path = path;\n    _lock = dispatch_semaphore_create(1);\n    _queue = dispatch_queue_create(\"com.ibireme.cache.disk\", DISPATCH_QUEUE_CONCURRENT);\n    _inlineThreshold = threshold;\n    _countLimit = NSUIntegerMax;\n    _costLimit = NSUIntegerMax;\n    _ageLimit = DBL_MAX;\n    _freeDiskSpaceLimit = 0;\n    _autoTrimInterval = 60;\n    \n    // 递归的去整理文件\n    [self _trimRecursively];\n    // 对当前对象进行缓存\n    _YYDiskCacheSetGlobal(self);\n    \n    // 通知 APP即将被杀死时\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_appWillBeTerminated) name:UIApplicationWillTerminateNotification object:nil];\n    return self;\n}\n\n```\n\n其他的一些操作基本上都是对YYKVStorage的一些封装，这边就不一一分析了。\n\n## 参考文献\n\n1. http://blog.ibireme.com/2015/10/26/yycache/\n2. http://blog.csdn.net/yunhua_lee/article/details/7599671\n","source":"_posts/YYCache-analyzing.md","raw":"---\ntitle: YYKit源码分析---YYCache\ndate: 2016-07-18 22:47:35\ncategories: iOS\ntags: [YYKit, YYCache]\n---\n[YYCache](https://github.com/ibireme/YYCache)是用于Objective-C中用于缓存的第三方框架。此文主要用来讲解该框架的实现细节，性能分析、设计思路ibireme已经讲得很清楚了，我这边就不在分析了。\n\n<!--more-->\n\n## 文件结构\n![](http://7xq5ax.com1.z0.glb.clouddn.com/yycache-tree.png)\n1. YYCache：同时实现内存缓存和磁盘缓存且是线程安全的\n2. YYMemoryCache：实现内存缓存，所有的API都是线程安全的，与其他缓存方式比较不同的是内部利用LRU淘汰算法（后面会介绍）来提高性能\n3. YYDiskCache：实现磁盘缓存，所有的API都是线程安全的，内部也采用了LRU淘汰算法，主要SQLite和文件存储两种方式\n4. YYKVStorage：实现磁盘存储，不推荐直接使用该类，该类不是线程安全的\n\n## LRU\nLRU(Least recently used，最近最少使用)算法，根据访问的历史记录来对数据进行淘汰\n<p>\n![](http://7xq5ax.com1.z0.glb.clouddn.com/lru.png)\n<p>\n简单的来说3点：\n\n1. 有新数据加入时添加到链表的头部\n2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部\n3. 当链表满的时候，将链表尾部的数据丢弃\n\n**在YYMemoryCache中使用来双向链表和NSDictionary实现了LRU淘汰算法，后面会介绍**\n\n## 关于锁\nYYCache 使用到两种锁\n\n1. OSSpinLock ：自旋锁，上一篇博客也提及到[pthread_mutex](http://iipanda.com/2016/06/21/YYKit-pthread/) \n2. dispatch_semaphore：信号量，当信号量为1的时候充当锁来用\n\n**内存缓存用的pthread_mutex：由于pthread_mutex相当于do while忙等，等待时会消耗大量的CPU资源<br>磁盘缓存使用的dispatch_semaphore：优势在于等待时不会消耗CPU资源**\n> 简单的科普就到这，现在来开始源码的探索\n\n## _YYLinkedMap\n```\n@interface _YYLinkedMapNode : NSObject {\n    @package\n    __unsafe_unretained _YYLinkedMapNode *_prev; // retained by dic\n    __unsafe_unretained _YYLinkedMapNode *_next; // retained by dic\n    id _key;\n    id _value;\n    NSUInteger _cost;\n    NSTimeInterval _time;\n}\n@end\n```\n**_YYLinkedMapNode**：链表的节点<br>\n\\_prev、\\_next：分别表示指向上一个节点、下一个节点<br>\n\\_key：缓存的key<br>\n\\_value：缓存对象<br>\n\\_cost：内存消耗<br>\n\\_time：缓存时间<br>\n\n```\n@interface _YYLinkedMap : NSObject {\n    @package\n    CFMutableDictionaryRef _dic; // do not set object directly\n    NSUInteger _totalCost;\n    NSUInteger _totalCount;\n    _YYLinkedMapNode *_head; // MRU（最近最常使用算法）, do not change it directly\n    _YYLinkedMapNode *_tail; // LRU（最近最少使用算法-清除较不常使用数据）, do not change it directly\n    BOOL _releaseOnMainThread;\n    BOOL _releaseAsynchronously;\n}\n\n```\n**_YYLinkedMap**：链表<br>\n\\_dic：用来保存节点<br>\n\\_totalCost：总缓存开销<br>\n\\_head、\\_tail：头节点、尾节点<br>\n\\_releaseOnMainThread：是否在主线程释放\\_YYLinkedMapNode<br>\n\\_releaseAsynchronously：是否异步释放\\_YYLinkedMapNode<br>\n\n\n**双向链表**<br>\n![](http://7xq5ax.com1.z0.glb.clouddn.com/LinkedMap@1x.png)\n\n1. 插入节点到头部\n2. 将除两边的节点移到头部\n3. 移除除两边的节点\n4. 移除尾部节点\n5. 移除所有节点\n\n看下移除所有节点的代码：\n\n```\n- (void)removeAll {\n    _totalCost = 0;\n    _totalCount = 0;\n    _head = nil;\n    _tail = nil;\n    if (CFDictionaryGetCount(_dic) > 0) {\n        CFMutableDictionaryRef holder = _dic;\n        _dic = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n        \n        if (_releaseAsynchronously) {\n            dispatch_queue_t queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();\n            dispatch_async(queue, ^{\n                CFRelease(holder); // hold and release in specified queue\n            });\n        } else if (_releaseOnMainThread && !pthread_main_np()) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                CFRelease(holder); // hold and release in specified queue\n            });\n        } else {\n            CFRelease(holder);\n        }\n    }\n}\n\n\n```\n\n\n\n这边通过双向链表来对数据进行操作，和NSDictionary实现了LRU淘汰算法。时间复杂度0（1），5种操作基本上都是对头尾节点和链表节点的上一个节点和下一个节点进行操作。\n\n\n## YYMemoryCache\n这边介绍两个主要的操作：添加缓存，查找缓存<p>\n\n- **添加缓存**\n\n```\n- (void)setObject:(id)object forKey:(id)key withCost:(NSUInteger)cost {\n    if (!key) return;\n    if (!object) {\n        // 缓存对象为nil，直接移除\n        [self removeObjectForKey:key];\n        return;\n    }\n    // 为了保证线程安全，数据操作前进行加锁\n    pthread_mutex_lock(&_lock);\n    // 查找缓存\n    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru->_dic, (__bridge const void *)(key));\n    // 当前时间\n    NSTimeInterval now = CACurrentMediaTime();\n    if (node) {\n        // 缓存对象已存在，更新数据，并移到栈顶\n        _lru->_totalCost -= node->_cost;\n        _lru->_totalCost += cost;\n        node->_cost = cost;\n        node->_time = now;\n        node->_value = object;\n        [_lru bringNodeToHead:node];\n    } else {\n        // 缓存对象不存在，添加数据，并移到栈顶\n        node = [_YYLinkedMapNode new];\n        node->_cost = cost;\n        node->_time = now;\n        node->_key = key;\n        node->_value = object;\n        [_lru insertNodeAtHead:node];\n    }\n    // 判断当前的缓存进行是否超出了设定值，若超出则进行整理\n    if (_lru->_totalCost > _costLimit) {\n        dispatch_async(_queue, ^{\n            [self trimToCost:_costLimit];\n        });\n    }\n    \n    // 每次添加数据仅有一个，数量上超出时，直接移除尾部那个object即可\n    if (_lru->_totalCount > _countLimit) {\n        _YYLinkedMapNode *node = [_lru removeTailNode];\n        if (_lru->_releaseAsynchronously) {\n            dispatch_queue_t queue = _lru->_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();\n            dispatch_async(queue, ^{\n                [node class]; //hold and release in queue\n            });\n        } else if (_lru->_releaseOnMainThread && !pthread_main_np()) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [node class]; //hold and release in queue\n            });\n        }\n    }\n    // 操作结束，解锁\n    pthread_mutex_unlock(&_lock);\n}\n\n```\n\n- **异步线程释放**\n![](http://7xq5ax.com1.z0.glb.clouddn.com/%E5%BC%82%E6%AD%A5%E9%87%8A%E6%94%BE.png)\n里面很多都用到类似的方法，将一个对象在异步线程中释放，来分析下：<br>\n\n\n\t\t- p\n\t\t1. 首先通过node来对其进行持有，以至于不会在方法调用结束的时候被销毁\n\t\t2. 我要要在其他线程中进行销毁，所以将销毁操作放在block中，block就会对其进行持有\n\t\t3. 这边在block中随便调用了个方法，保证编译器不会优化掉这个操作\n\t\t4. 当block结束后，node没有被持有的时候，就会在当前线程被release掉了\n\n\n\n- **添加缓存**\n\n```\n// 这边从memory中取数据时，根据LRU原则，将最新取出的object放到栈头\n- (id)objectForKey:(id)key {\n    if (!key) return nil;\n    pthread_mutex_lock(&_lock);\n    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru->_dic, (__bridge const void *)(key));\n    if (node) {\n        node->_time = CACurrentMediaTime();\n        [_lru bringNodeToHead:node];\n    }\n    pthread_mutex_unlock(&_lock);\n    return node ? node->_value : nil;\n}\n\n```\n\n## YYKVStorage\n\n该文件主要以两种方式来实现磁盘存储：SQLite、File，使用两种方式混合进行存储主要为了提高读写效率。写入数据时，SQLite要比文件的方式更快；读取数据的速度主要取决于文件的大小。据测试，在iPhone6中，当文件大小超过20kb时，File要比SQLite快的多。所以当大文件存储时建议用File的方式，小文件更适合用SQLite。<p>\n下边分别对Save、Remove、Get分别进行分析\n\n\n- **Save**\n\n```\n- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(NSString *)filename extendedData:(NSData *)extendedData {\n    // 条件不符合\n    if (key.length == 0 || value.length == 0) return NO;\n    if (_type == YYKVStorageTypeFile && filename.length == 0) {\n        return NO;\n    }\n    \n    if (filename.length) {    // filename存在 SQLite File两种方式并行\n        // 用文件进行存储\n        if (![self _fileWriteWithName:filename data:value]) {\n            return NO;\n        }\n        // 用SQLite进行存储\n        if (![self _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) {\n            // 当使用SQLite方式存储失败时，删除本地文件存储\n            [self _fileDeleteWithName:filename];\n            return NO;\n        }\n        return YES;\n    } else {               // filename不存在 SQLite\n        if (_type != YYKVStorageTypeSQLite) {\n            // 这边去到filename后，删除filename对应的file文件\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            if (filename) {\n                [self _fileDeleteWithName:filename];\n            }\n        }\n        // SQLite 进行存储\n        return [self _dbSaveWithKey:key value:value fileName:nil extendedData:extendedData];\n    }\n}\n\n\n```\n\n- **Remove**\n\n```\n- (BOOL)removeItemForKey:(NSString *)key {\n    if (key.length == 0) return NO;\n    switch (_type) {\n        case YYKVStorageTypeSQLite: {\n            // 删除SQLite文件\n            return [self _dbDeleteItemWithKey:key];\n        } break;\n        case YYKVStorageTypeFile:\n        case YYKVStorageTypeMixed: {\n            // 获取filename\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            if (filename) {\n                // 删除filename对的file\n                [self _fileDeleteWithName:filename];\n            }\n            // 删除SQLite文件\n            return [self _dbDeleteItemWithKey:key];\n        } break;\n        default: return NO;\n    }\n}\n\n```\n\n- **Get**\n\n```\n- (NSData *)getItemValueForKey:(NSString *)key {\n    if (key.length == 0) return nil;\n    NSData *value = nil;\n    switch (_type) {\n        case YYKVStorageTypeFile: { //File\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            if (filename) {\n                // 根据filename获取File\n                value = [self _fileReadWithName:filename];\n                if (!value) {\n                    // 当value不存在，用对应的key删除SQLite文件\n                    [self _dbDeleteItemWithKey:key];\n                    value = nil;\n                }\n            }\n        } break;\n        case YYKVStorageTypeSQLite: {\n            // SQLite 方式获取\n            value = [self _dbGetValueWithKey:key];\n        } break;\n        case YYKVStorageTypeMixed: {\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            // filename 存在文件获取，不存在SQLite方式获取\n            if (filename) {\n                value = [self _fileReadWithName:filename];\n                if (!value) {\n                    [self _dbDeleteItemWithKey:key];\n                    value = nil;\n                }\n            } else {\n                value = [self _dbGetValueWithKey:key];\n            }\n        } break;\n    }\n    if (value) {\n        // 更新文件操作时间\n        [self _dbUpdateAccessTimeWithKey:key];\n    }\n    return value;\n}\n\n```\n\nFile方式主要使用的writeToFile进行存储，SQLte直接使用的sqlite3来对文件进行操作，具体数据库相关的操作这边就不在进行分析了，感兴趣的自己可以阅读下\n\n## YYDiskCache\n\nYYDiskCache是对YYKVStorage进行的一次封装，是线程安全的，这边使用的是dispatch_semaphore_signal来确保线程的安全。另外他结合LRU算法，根据文件的大小自动选择存储方式来达到更好的性能。\n\n```\n- (instancetype)initWithPath:(NSString *)path\n             inlineThreshold:(NSUInteger)threshold {\n    self = [super init];\n    if (!self) return nil;\n    \n    // 获取缓存的 YYDiskCache\n    YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);\n    if (globalCache) return globalCache;\n    \n    // 确定存储的方式\n    YYKVStorageType type;\n    if (threshold == 0) {\n        type = YYKVStorageTypeFile;\n    } else if (threshold == NSUIntegerMax) {\n        type = YYKVStorageTypeSQLite;\n    } else {\n        type = YYKVStorageTypeMixed;\n    }\n    \n    // 初始化 YYKVStorage\n    YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type];\n    if (!kv) return nil;\n    \n    // 初始化数据\n    _kv = kv;\n    _path = path;\n    _lock = dispatch_semaphore_create(1);\n    _queue = dispatch_queue_create(\"com.ibireme.cache.disk\", DISPATCH_QUEUE_CONCURRENT);\n    _inlineThreshold = threshold;\n    _countLimit = NSUIntegerMax;\n    _costLimit = NSUIntegerMax;\n    _ageLimit = DBL_MAX;\n    _freeDiskSpaceLimit = 0;\n    _autoTrimInterval = 60;\n    \n    // 递归的去整理文件\n    [self _trimRecursively];\n    // 对当前对象进行缓存\n    _YYDiskCacheSetGlobal(self);\n    \n    // 通知 APP即将被杀死时\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_appWillBeTerminated) name:UIApplicationWillTerminateNotification object:nil];\n    return self;\n}\n\n```\n\n其他的一些操作基本上都是对YYKVStorage的一些封装，这边就不一一分析了。\n\n## 参考文献\n\n1. http://blog.ibireme.com/2015/10/26/yycache/\n2. http://blog.csdn.net/yunhua_lee/article/details/7599671\n","slug":"YYCache-analyzing","published":1,"updated":"2017-01-03T04:28:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiitluf3000r55cg8i2v3k13"},{"title":"浅谈Socket学习中的那些事","date":"2016-01-16T13:17:20.000Z","_content":"\nSocket是为网络服务提供的一种机制，希望经过此次的学习，能够揭开Socket神秘面纱。在此仅想记录自己的学习历程和一些学习心得。\n<!--more-->\n\n# OSI、TCP\\IP参考模型\n<p>\n\n![](http://7xq5ax.com1.z0.glb.clouddn.com/OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.png)\n<p>\n\n## 简单解释\n\n1. 物理层：主要定义物理设备标准，如网线的接口类型、各种传输介质的传输速率等。2. \n\n2. 数据链路层：主要将从物理层接收的数据进行MAC地址的封装与解封装。\n\n3. 网络层：选择合适的网间路由和交换结点，确保数据及时传送，将从下层接收到的数据进行IP地址的封装与解封装。\n\n4. 传输层：定义了一些传输数据的协议和端口，如TCP、UDP协议，主要将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，以往把这一层数据叫做段。\n\n5. 会话层：通过传输层建立数据传输通路。\n\n6. 表示层：主要是进行对接收的数据进行解释、压缩与解压缩等，即把计算机能够识别的东西转化成人能够识别的东西（如图片、声音等）。\n\n7. 应用层：主要是一些终端的应用，比如说FTP（各种文件下载）、浏览器、QQ等，可以将其理解为在电脑屏幕上可以看到的东西，也就是终端应用。<p>\n\n## 网络通讯要素\n\n**IP地址**：网络中设备的标示\n\n**端口号**：用来标示进程的逻辑地址，不同进程的标示\n\n**传输协议**：用什么样的方式进行交互，常见协议TCP/UDP\n\n# TCP/UDP\n\n**TCP（传输控制协议）**\n\n1. 建立连接，形成数据传输的通道\n\n2. 在连接中可进行大数据传输（数据的大小不受限制）\n\n3. 通过三次握手建立连接，可靠协议，安全送达\n\n4. 先建立连接，效率较低<p>\n\n**UDP（用户数据报协议）**\n\n1. 不需要建立连接，将数据封装在数据包中\n\n2. 每个数据包得大小限制在64k之内\n\n3. 无需连接，是不可靠协议\n\n4. 不需要连接，速度较快\n\n\n# Socket\n\n## 简单解释\n\n1. 网络提供服务的一种机制\n \n2. 通信的两端都是socket\n\n3. 网络通信其实就是socket间的通信\n\n4. 数据在两个socket间通过IO传输\n\n![](http://7xq5ax.com1.z0.glb.clouddn.com/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81.png)\n\n## iOS中常用的两种Socket类型\n\n**流式Socket（SOCK_STREAM）**：流式是一种面向连接的Socket，针对于面向连接的TCP服务应用\n\n**数据报式Socket（SOCK_DGRAM）**：数据报式Socket是一种无连接的Socket，对应于无连接的UDP服务应用\n\n## Http与Socket的区别\n\n1. Http是基于Socket的实现；Http应用层协议，主要解决如何包装数据\n\n2. Http传输的数据格式是规定好的，Socket实现数据传输是最原始，Socket实现的数据传输格式可自定义\n\n3. Http建立的连接称为短连接，Socket建立的连接为长连接\n\n4. Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API),通过Socket我们才能使用TCP/IP协议\n\n# 最后\n<p>\n在学习的过程中会模仿微信做类似的demo，涉及到的一些相关地址如下：\n\n1. iOS XMPP框架：https://github.com/robbiehanson/XMPPFramework\n\n2. Server：http://www.igniterealtime.org/downloads/index.jsp\n\n3. 数据库：http://dev.mysql.com/downloads/mysql/\n\n\n\n\n\n\n\n\n","source":"_posts/Socket.md","raw":"---\ntitle: 浅谈Socket学习中的那些事\ndate: 2016-01-16 21:17:20\ncategories: iOS\ntags: [SOCKET, HTTP, TCP, UDP]\n---\n\nSocket是为网络服务提供的一种机制，希望经过此次的学习，能够揭开Socket神秘面纱。在此仅想记录自己的学习历程和一些学习心得。\n<!--more-->\n\n# OSI、TCP\\IP参考模型\n<p>\n\n![](http://7xq5ax.com1.z0.glb.clouddn.com/OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.png)\n<p>\n\n## 简单解释\n\n1. 物理层：主要定义物理设备标准，如网线的接口类型、各种传输介质的传输速率等。2. \n\n2. 数据链路层：主要将从物理层接收的数据进行MAC地址的封装与解封装。\n\n3. 网络层：选择合适的网间路由和交换结点，确保数据及时传送，将从下层接收到的数据进行IP地址的封装与解封装。\n\n4. 传输层：定义了一些传输数据的协议和端口，如TCP、UDP协议，主要将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，以往把这一层数据叫做段。\n\n5. 会话层：通过传输层建立数据传输通路。\n\n6. 表示层：主要是进行对接收的数据进行解释、压缩与解压缩等，即把计算机能够识别的东西转化成人能够识别的东西（如图片、声音等）。\n\n7. 应用层：主要是一些终端的应用，比如说FTP（各种文件下载）、浏览器、QQ等，可以将其理解为在电脑屏幕上可以看到的东西，也就是终端应用。<p>\n\n## 网络通讯要素\n\n**IP地址**：网络中设备的标示\n\n**端口号**：用来标示进程的逻辑地址，不同进程的标示\n\n**传输协议**：用什么样的方式进行交互，常见协议TCP/UDP\n\n# TCP/UDP\n\n**TCP（传输控制协议）**\n\n1. 建立连接，形成数据传输的通道\n\n2. 在连接中可进行大数据传输（数据的大小不受限制）\n\n3. 通过三次握手建立连接，可靠协议，安全送达\n\n4. 先建立连接，效率较低<p>\n\n**UDP（用户数据报协议）**\n\n1. 不需要建立连接，将数据封装在数据包中\n\n2. 每个数据包得大小限制在64k之内\n\n3. 无需连接，是不可靠协议\n\n4. 不需要连接，速度较快\n\n\n# Socket\n\n## 简单解释\n\n1. 网络提供服务的一种机制\n \n2. 通信的两端都是socket\n\n3. 网络通信其实就是socket间的通信\n\n4. 数据在两个socket间通过IO传输\n\n![](http://7xq5ax.com1.z0.glb.clouddn.com/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81.png)\n\n## iOS中常用的两种Socket类型\n\n**流式Socket（SOCK_STREAM）**：流式是一种面向连接的Socket，针对于面向连接的TCP服务应用\n\n**数据报式Socket（SOCK_DGRAM）**：数据报式Socket是一种无连接的Socket，对应于无连接的UDP服务应用\n\n## Http与Socket的区别\n\n1. Http是基于Socket的实现；Http应用层协议，主要解决如何包装数据\n\n2. Http传输的数据格式是规定好的，Socket实现数据传输是最原始，Socket实现的数据传输格式可自定义\n\n3. Http建立的连接称为短连接，Socket建立的连接为长连接\n\n4. Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API),通过Socket我们才能使用TCP/IP协议\n\n# 最后\n<p>\n在学习的过程中会模仿微信做类似的demo，涉及到的一些相关地址如下：\n\n1. iOS XMPP框架：https://github.com/robbiehanson/XMPPFramework\n\n2. Server：http://www.igniterealtime.org/downloads/index.jsp\n\n3. 数据库：http://dev.mysql.com/downloads/mysql/\n\n\n\n\n\n\n\n\n","slug":"Socket","published":1,"updated":"2017-01-03T04:28:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiitluf6000w55cgm4ggevrh"},{"title":"Runtime实战之定制TabBarItem大小","date":"2016-05-11T14:17:26.000Z","_content":"本篇blog主要讲解如何定制TabBarItem的大小，最终实现AppStore各大主流APP TabBarItem超出TabBar的效果。\n<!--more-->\n\n# 方案一：UIEdgeInsets\n**适用场景：** <br>\n\n- 适合APP的TabBarItemImage的图片资源放在本地\n- 图片超出tabbar的高度，需移动其位置，来进行适应\n\n**弊端：** <br>\n\n若在本地配置好后，tabbar的图片就不能改动了，若tabbar的图片来自服务端，且不停的切换图片的大小，以上则很难满足。若有此方面的需求请看方案二。\n\n**实现：** <br>\n\n` [tabbarItem setImageInsets:UIEdgeInsetsMake(<#CGFloat top#>, <#CGFloat left#>, <#CGFloat bottom#>, <#CGFloat right#>)]` \n\n注：图片太大超出tabbar时，系统并不会调整image和title的位置，你需要根据图片的高度，计算出需要往上移动的高度，然后设置top和bottom属性即可。切记top = - bottom，否则image将会被拉伸或者被压缩。\n\n\n# 方案二：Runtime\n利用runtime的话相对方案一来说要比较复杂一点，但其灵活度比较高，我们能够根据服务端所给的image来动态的变化TabBarItem的大小，类似像淘宝、京东活动时。思想：主要是利用runtime对UITabBar的layoutSubviews进行重写，然后调整UITabBarItem的位置。另外，当时在做的APP已经有4-5年的历史了，一开始打算自已定制tabbar，发现要改动的还是挺多的，于是就放弃了。做之前也看了前辈iOS程序犭袁的[CYLTabBarController](https://github.com/ChenYilong/CYLTabBarController)，从中也学到了不少思路。\n\n\n**实现：** <br>\n1. 首先我们使用runtime method swizzling交换系统的`- (void)layoutSubviews;` <br>\n2. 使用KVC对系统的UITabBarButton、UITabBarSwappableImageView、UITabBarButtonLabel、_UIBadgeView进行捕获 <br> \n3. 拿到控件后我们对其的frame进行计算，判断当前有没有超出tabbar的高度，若超出则进行处理 <br>\n4. 再次利用runtime method swizzling交换系统的`- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;`使图片超过后也能接受点击 <br>\n\n**代码：** <br>\n\n- method swizzling：\n\n```\nstatic void ExchangedMethod(SEL originalSelector, SEL swizzledSelector, Class class) {\n    \n    Method originalMethod = class_getInstanceMethod(class, originalSelector);\n    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n    \n    BOOL didAddMethod =\n    class_addMethod(class,\n                    originalSelector,\n                    method_getImplementation(swizzledMethod),\n                    method_getTypeEncoding(swizzledMethod));\n    \n    if (didAddMethod) {\n        class_replaceMethod(class,\n                            swizzledSelector,\n                            method_getImplementation(originalMethod),\n                            method_getTypeEncoding(originalMethod));\n    }\n    else {\n        method_exchangeImplementations(originalMethod, swizzledMethod);\n    }\n}\n\n```\n- 计算frame，并对其重新布局\n\n```\nUIView *tabBarImageView, *tabBarButtonLabel, *tabBarBadgeView;\n        for (UIView *sTabBarItem in childView.subviews) {\n            if ([sTabBarItem isKindOfClass:NSClassFromString(@\"UITabBarSwappableImageView\")]) {\n                tabBarImageView = sTabBarItem;\n            }\n            else if ([sTabBarItem isKindOfClass:NSClassFromString(@\"UITabBarButtonLabel\")]) {\n                tabBarButtonLabel = sTabBarItem;\n            }\n            else if ([sTabBarItem isKindOfClass:NSClassFromString(@\"_UIBadgeView\")]) {\n                tabBarBadgeView = sTabBarItem;\n            }\n        }\n\n        NSString *tabBarButtonLabelText = ((UILabel *)tabBarButtonLabel).text;\n  \n        CGFloat y = CGRectGetHeight(self.bounds) - (CGRectGetHeight(tabBarButtonLabel.bounds) + CGRectGetHeight(tabBarImageView.bounds));\n        if (y < 3) {\n            if (!tabBarButtonLabelText.length) {\n                space -= tabBarButtonLabelHeight;\n            }\n            \n            childView.frame = CGRectMake(childView.frame.origin.x,\n                                         y - space,\n                                         childView.frame.size.width,\n                                         childView.frame.size.height - y + space\n                                         );\n        }\n\n```\n\n- 让图片超出部分也能响应点击事件\n\n```\n- (UIView *)s_hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n    if (!self.clipsToBounds && !self.hidden && self.alpha > 0) {\n        UIView *result = [super hitTest:point withEvent:event];\n        if (result) {\n            return result;\n        }\n        else {\n            for (UIView *subview in self.subviews.reverseObjectEnumerator) {\n                CGPoint subPoint = [subview convertPoint:point fromView:self];\n                result = [subview hitTest:subPoint withEvent:event];\n                if (result) {\n                    return result;\n                }\n            }\n        }\n    }\n    return nil;\n}\n\n```\n# 注意事项\n\n- 在给tabbar设置图片的时候一定要设置图片的`renderingMode`，否则就会出现下图中图片丢失的现象\n- UITabBarButton被修改frame之后，仅有UITabBarSwappableImageView能够响应点击事件，不过我们能够在UITabBar的`- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;`方法中捕获到\n- 当适配图片后不要忘记适配`_UIBadgeView`的frame\n\n\n# 效果图\n- 正常中间超出 <br>\n![部分超出](http://7xq5ax.com1.z0.glb.clouddn.com/tabbar_image_render.png)<br>\n- 做活动时全部超出 <br>\n![全部超出](http://7xq5ax.com1.z0.glb.clouddn.com/tabbar_more_all.png)<br>\n- 图片丢失 <br>\n![图片丢失](http://7xq5ax.com1.z0.glb.clouddn.com/tabbar_more.png)<br>\n- UIBadgeView <br>\n![](http://7xq5ax.com1.z0.glb.clouddn.com/badgevalue.png)\n\n> 感谢大家花费时间来查看这篇blog，需要下载demo的同学请猛戳[Git](https://github.com/PanXianyue/BlogDemo)。","source":"_posts/Runtime-tabBarItem.md","raw":"---\ntitle: Runtime实战之定制TabBarItem大小\ndate: 2016-05-11 22:17:26\ncategories: iOS\ntags:\n---\n本篇blog主要讲解如何定制TabBarItem的大小，最终实现AppStore各大主流APP TabBarItem超出TabBar的效果。\n<!--more-->\n\n# 方案一：UIEdgeInsets\n**适用场景：** <br>\n\n- 适合APP的TabBarItemImage的图片资源放在本地\n- 图片超出tabbar的高度，需移动其位置，来进行适应\n\n**弊端：** <br>\n\n若在本地配置好后，tabbar的图片就不能改动了，若tabbar的图片来自服务端，且不停的切换图片的大小，以上则很难满足。若有此方面的需求请看方案二。\n\n**实现：** <br>\n\n` [tabbarItem setImageInsets:UIEdgeInsetsMake(<#CGFloat top#>, <#CGFloat left#>, <#CGFloat bottom#>, <#CGFloat right#>)]` \n\n注：图片太大超出tabbar时，系统并不会调整image和title的位置，你需要根据图片的高度，计算出需要往上移动的高度，然后设置top和bottom属性即可。切记top = - bottom，否则image将会被拉伸或者被压缩。\n\n\n# 方案二：Runtime\n利用runtime的话相对方案一来说要比较复杂一点，但其灵活度比较高，我们能够根据服务端所给的image来动态的变化TabBarItem的大小，类似像淘宝、京东活动时。思想：主要是利用runtime对UITabBar的layoutSubviews进行重写，然后调整UITabBarItem的位置。另外，当时在做的APP已经有4-5年的历史了，一开始打算自已定制tabbar，发现要改动的还是挺多的，于是就放弃了。做之前也看了前辈iOS程序犭袁的[CYLTabBarController](https://github.com/ChenYilong/CYLTabBarController)，从中也学到了不少思路。\n\n\n**实现：** <br>\n1. 首先我们使用runtime method swizzling交换系统的`- (void)layoutSubviews;` <br>\n2. 使用KVC对系统的UITabBarButton、UITabBarSwappableImageView、UITabBarButtonLabel、_UIBadgeView进行捕获 <br> \n3. 拿到控件后我们对其的frame进行计算，判断当前有没有超出tabbar的高度，若超出则进行处理 <br>\n4. 再次利用runtime method swizzling交换系统的`- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;`使图片超过后也能接受点击 <br>\n\n**代码：** <br>\n\n- method swizzling：\n\n```\nstatic void ExchangedMethod(SEL originalSelector, SEL swizzledSelector, Class class) {\n    \n    Method originalMethod = class_getInstanceMethod(class, originalSelector);\n    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n    \n    BOOL didAddMethod =\n    class_addMethod(class,\n                    originalSelector,\n                    method_getImplementation(swizzledMethod),\n                    method_getTypeEncoding(swizzledMethod));\n    \n    if (didAddMethod) {\n        class_replaceMethod(class,\n                            swizzledSelector,\n                            method_getImplementation(originalMethod),\n                            method_getTypeEncoding(originalMethod));\n    }\n    else {\n        method_exchangeImplementations(originalMethod, swizzledMethod);\n    }\n}\n\n```\n- 计算frame，并对其重新布局\n\n```\nUIView *tabBarImageView, *tabBarButtonLabel, *tabBarBadgeView;\n        for (UIView *sTabBarItem in childView.subviews) {\n            if ([sTabBarItem isKindOfClass:NSClassFromString(@\"UITabBarSwappableImageView\")]) {\n                tabBarImageView = sTabBarItem;\n            }\n            else if ([sTabBarItem isKindOfClass:NSClassFromString(@\"UITabBarButtonLabel\")]) {\n                tabBarButtonLabel = sTabBarItem;\n            }\n            else if ([sTabBarItem isKindOfClass:NSClassFromString(@\"_UIBadgeView\")]) {\n                tabBarBadgeView = sTabBarItem;\n            }\n        }\n\n        NSString *tabBarButtonLabelText = ((UILabel *)tabBarButtonLabel).text;\n  \n        CGFloat y = CGRectGetHeight(self.bounds) - (CGRectGetHeight(tabBarButtonLabel.bounds) + CGRectGetHeight(tabBarImageView.bounds));\n        if (y < 3) {\n            if (!tabBarButtonLabelText.length) {\n                space -= tabBarButtonLabelHeight;\n            }\n            \n            childView.frame = CGRectMake(childView.frame.origin.x,\n                                         y - space,\n                                         childView.frame.size.width,\n                                         childView.frame.size.height - y + space\n                                         );\n        }\n\n```\n\n- 让图片超出部分也能响应点击事件\n\n```\n- (UIView *)s_hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n    if (!self.clipsToBounds && !self.hidden && self.alpha > 0) {\n        UIView *result = [super hitTest:point withEvent:event];\n        if (result) {\n            return result;\n        }\n        else {\n            for (UIView *subview in self.subviews.reverseObjectEnumerator) {\n                CGPoint subPoint = [subview convertPoint:point fromView:self];\n                result = [subview hitTest:subPoint withEvent:event];\n                if (result) {\n                    return result;\n                }\n            }\n        }\n    }\n    return nil;\n}\n\n```\n# 注意事项\n\n- 在给tabbar设置图片的时候一定要设置图片的`renderingMode`，否则就会出现下图中图片丢失的现象\n- UITabBarButton被修改frame之后，仅有UITabBarSwappableImageView能够响应点击事件，不过我们能够在UITabBar的`- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;`方法中捕获到\n- 当适配图片后不要忘记适配`_UIBadgeView`的frame\n\n\n# 效果图\n- 正常中间超出 <br>\n![部分超出](http://7xq5ax.com1.z0.glb.clouddn.com/tabbar_image_render.png)<br>\n- 做活动时全部超出 <br>\n![全部超出](http://7xq5ax.com1.z0.glb.clouddn.com/tabbar_more_all.png)<br>\n- 图片丢失 <br>\n![图片丢失](http://7xq5ax.com1.z0.glb.clouddn.com/tabbar_more.png)<br>\n- UIBadgeView <br>\n![](http://7xq5ax.com1.z0.glb.clouddn.com/badgevalue.png)\n\n> 感谢大家花费时间来查看这篇blog，需要下载demo的同学请猛戳[Git](https://github.com/PanXianyue/BlogDemo)。","slug":"Runtime-tabBarItem","published":1,"updated":"2017-01-03T04:28:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiitlufa001655cgcp8a6urt"},{"title":"一篇搞定RSA加密与SHA签名","date":"2016-01-12T09:19:25.000Z","_content":"\n看到这篇文章的同学可幸福了，当时在做RSA加密与签名的时候网上的资料简直不要太老，做完后实在是忍受不下去了，这篇文章我会详细讲解iOS如何实现RSA加密与签名，并且与Java完全同步。\n<!--more-->\n\n# 基础知识 \n\n <p>\n\n1. **什么是RSA？**<p>\n答：RSA是一种非对称加密算法，常用来对传输数据进行加密，配合上数字摘要算法，也可以进行文字签名。\n\n2. **RSA加密中padding？**<p>\n答：padding即填充方式，由于RSA加密算法中要加密的明文是要比模数小的，padding就是通过一些填充方式来限制明文的长度。后面会详细介绍padding的几种模式以及分段加密。\n\n3. **加密和加签有什么区别？**<p>\n答：加密：公钥放在客户端，并使用公钥对数据进行加密，服务端拿到数据后用私钥进行解密； \n      加签：私钥放在客户端，并使用私钥对数据进行加签，服务端拿到数据后用公钥进行验签。       \n前者完全为了加密；后者主要是为了防恶意攻击，防止别人模拟我们的客户端对我们的服务器进行攻击，导致服务器瘫痪。\n\n# 基本原理<p>\n\nRSA使用“密钥对”对数据进行加密解密，在加密解密前需要先生存公钥（Public Key）和私钥（Private Key）。<p>\n**公钥(Public key):** 用于加密数据. 用于公开, 一般存放在数据提供方, 例如iOS客户端。<p>\n**私钥(Private key):** 用于解密数据. 必须保密, 私钥泄露会造成安全问题。<p>\niOS中的Security.framework提供了对RSA算法的支持，这种方式需要对密匙对进行处理, 根据public key生成证书, 通过private key生成p12格式的密匙。想想jave直接用字符串进行加密解密简单多了。(⊙o⊙)…\n\n# 实战\n<p>\n## 证书生成\nRSA加密这块公钥、私钥必不可少的。**Apple是不支持直接使用字符串进行加密解密的，推荐使用p12文件**。这边教大家去生成在加密中使用到的所有文件，并提供给Java使用，想当年这个公钥私钥搞了半天了。 %>_<%\n\n>* 生成模长为1024bit的私钥\nopenssl genrsa -out private_key.pem 1024\n* 生成certification require file\nopenssl req -new -key private_key.pem -out rsaCertReq.csr \n* 生成certification 并指定过期时间\nopenssl x509 -req -days3650-in rsaCertReq.csr -signkey private_key.pem -out rsaCert.crt\n* 生成公钥供iOS使用\nopenssl x509 -outform der -in rsaCert.crt -out public_key.der\n* 生成私钥供iOS使用 这边会让你输入密码，后期用到在生成secKeyRef的时候会用到这个密码\nopenssl pkcs12 -export -out private_key.p12 -inkey private_key.pem -in rsaCert.crt\n* 生成pem结尾的公钥供Java使用\nopenssl rsa -in private_key.pem -out rsa_public_key.pem -pubout\n* 生成pem结尾的私钥供Java使用openssl pkcs8 -topk8 -in private_key.pem -out pkcs8_private_key.pem -nocrypt\n\n**以上所有的步骤都是在终端下完成的哦  (*^__^*)**\n\n## 生成公钥和私钥的secKeyRef<p>\n   ```\n   //根据你的p12文件生成私钥对应的SecKeyRef 这边返回若是nil 请检查你p12文件的生成步骤\n- (SecKeyRef)getPrivateKeyRefrenceFromData:(NSData*)p12Data password:(NSString*)password {\n\nSecKeyRef privateKeyRef = NULL;\nNSMutableDictionary * options = [[NSMutableDictionary alloc] init];\n[options setObject: password forKey:(__bridge id)kSecImportExportPassphrase];\nCFArrayRef items = CFArrayCreate(NULL, 0, 0, NULL);\nOSStatus securityError = SecPKCS12Import((__bridge CFDataRef) p12Data, (__bridge CFDictionaryRef)options, &items);\nif (securityError == noErr && CFArrayGetCount(items) > 0) {\n    CFDictionaryRef identityDict = CFArrayGetValueAtIndex(items, 0);\n    SecIdentityRef identityApp = (SecIdentityRef)CFDictionaryGetValue(identityDict, kSecImportItemIdentity);\n    securityError = SecIdentityCopyPrivateKey(identityApp, &privateKeyRef);\n    if (securityError != noErr) {\n        privateKeyRef = NULL;\n    }\n}\nCFRelease(items);\n\nreturn privateKeyRef;\n}  \n   ```\n   \n   \n   ```\n    //根据你的der文件公钥对应的SecKeyRef\n - (SecKeyRef)getPublicKeyRefrenceFromeData:    (NSData*)derData {\n\nSecCertificateRef myCertificate = SecCertificateCreateWithData(kCFAllocatorDefault, (__bridge CFDataRef)derData);\nSecPolicyRef myPolicy = SecPolicyCreateBasicX509();\nSecTrustRef myTrust;\nOSStatus status = SecTrustCreateWithCertificates(myCertificate,myPolicy,&myTrust);\nSecTrustResultType trustResult;\nif (status == noErr) {\n    status = SecTrustEvaluate(myTrust, &trustResult);\n}\nSecKeyRef securityKey = SecTrustCopyPublicKey(myTrust);\nCFRelease(myCertificate);\nCFRelease(myPolicy);\nCFRelease(myTrust);\n\nreturn securityKey;\n}\n   ```\n   \n## 加密与解密 <p>\n \n ```\n - (NSData*)rsaEncryptData:(NSData*)data {\n    SecKeyRef key = [self getPublicKey];\n    size_t cipherBufferSize = SecKeyGetBlockSize(key);\n    uint8_t *cipherBuffer = malloc(cipherBufferSize * sizeof(uint8_t));\n    size_t blockSize = cipherBufferSize - 11;\n      size_t blockCount = (size_t)ceil([data length] / (double)blockSize);\n      NSMutableData *encryptedData = [[NSMutableData alloc] init];\n    for (int i=0; i<blockCount; i++) {\n    unsigned long bufferSize = MIN(blockSize , [data length] - i * blockSize);\n    NSData *buffer = [data subdataWithRange:NSMakeRange(i * blockSize, bufferSize)];\n    OSStatus status = SecKeyEncrypt(key, kSecPaddingPKCS1, (const uint8_t *)[buffer bytes], [buffer length], cipherBuffer, &cipherBufferSize);\n\n    if (status != noErr) {\n        return nil;\n    }\n\n    NSData *encryptedBytes = [[NSData alloc] initWithBytes:(const void *)cipherBuffer length:cipherBufferSize];\n    [encryptedData appendData:encryptedBytes];\n    }\n\n  if (cipherBuffer){\n    free(cipherBuffer);\n  }\n\n  return encryptedData;\n  }\n ```\n \n ```\n - (NSData*)rsaDecryptData:(NSData*)data {\nSecKeyRef key = [self getPrivatKey];\n\nsize_t cipherBufferSize = SecKeyGetBlockSize(key);\nsize_t blockSize = cipherBufferSize;\nsize_t blockCount = (size_t)ceil([data length] / (double)blockSize);\n\nNSMutableData *decryptedData = [[NSMutableData alloc] init];\n\nfor (int i = 0; i < blockCount; i++) {\n    unsigned long bufferSize = MIN(blockSize , [data length] - i * blockSize);\n    NSData *buffer = [data subdataWithRange:NSMakeRange(i * blockSize, bufferSize)];\n\n    size_t cipherLen = [buffer length];\n    void *cipher = malloc(cipherLen);\n    [buffer getBytes:cipher length:cipherLen];\n    size_t plainLen = SecKeyGetBlockSize(key);\n    void *plain = malloc(plainLen);\n\n    OSStatus status = SecKeyDecrypt(key, kSecPaddingPKCS1, cipher, cipherLen, plain, &plainLen);\n\n    if (status != noErr) {\n        return nil;\n    }\n\n    NSData *decryptedBytes = [[NSData alloc] initWithBytes:(const void *)plain length:plainLen];\n    [decryptedData appendData:decryptedBytes];\n}\n\nreturn decryptedData;\n}\n ```\n \n### RSA加密中的Padding \n\n* RSA_PKCS1_PADDING 填充模式，最常用的模式<p>\n要求: 输入：必须 比 RSA 钥模长(modulus) 短至少11个字节, 也就是　RSA_size(rsa) – 11 如果输入的明文过长，必须切割，然后填充。<p>\n输出：和modulus一样长<p>\n根据这个要求，对于1024bit的密钥，block length = 1024/8 – 11 = 117 字节<p>\n\n* RSA_PKCS1_OAEP_PADDING<p>\n输入：RSA_size(rsa) – 41<p>\n输出：和modulus一样长<p>\n\n* RSA_NO_PADDING　　不填充<p>\n输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，　然后填充<p>\n输出：和modulus一样长<p>\n\n## 签名与验证\n\n```\n //对数据进行sha256签名\n- (NSData *)rsaSHA256SignData:(NSData *)plainData {\n      SecKeyRef key = [self getPrivatKey];\n    \n      size_t signedHashBytesSize = SecKeyGetBlockSize(key);\n      uint8_t* signedHashBytes = malloc(signedHashBytesSize);\n      memset(signedHashBytes, 0x0, signedHashBytesSize);\n    \n      size_t hashBytesSize = CC_SHA256_DIGEST_LENGTH;\n      uint8_t* hashBytes = malloc(hashBytesSize);\n      if (!CC_SHA256([plainData bytes], (CC_LONG)[plainData length], hashBytes)) {\n        return nil;\n    }\n    \n           SecKeyRawSign(key,\n                  kSecPaddingPKCS1SHA256,\n                  hashBytes,\n                  hashBytesSize,\n                  signedHashBytes,\n                  &signedHashBytesSize);\n    \n        NSData* signedHash = [NSData dataWithBytes:signedHashBytes\n                                        length:(NSUInteger)signedHashBytesSize];\n    \n        if (hashBytes)\n        free(hashBytes);\n    if (signedHashBytes)\n        free(signedHashBytes);\n    \n        return signedHash;\n}\n        \n```\n\n\n```\n\n//这边对签名的数据进行验证 验签成功，则返回YES\n- (BOOL)rsaSHA256VerifyData:(NSData *)plainData     withSignature:(NSData *)signature {\n        SecKeyRef key = [self getPublicKey];\n  \n        size_t signedHashBytesSize = SecKeyGetBlockSize(key);\n        const void* signedHashBytes = [signature bytes];\n    \n        size_t hashBytesSize = CC_SHA256_DIGEST_LENGTH;\n        uint8_t* hashBytes = malloc(hashBytesSize);\n        if (!CC_SHA256([plainData bytes], (CC_LONG)[plainData length], hashBytes)) {\n           return NO;\n        }\n    \n          OSStatus status = SecKeyRawVerify(key,\n                                      kSecPaddingPKCS1SHA256,\n                                      hashBytes,\n                                      hashBytesSize,\n                                      signedHashBytes,\n                                      signedHashBytesSize);\n    \n        return status == errSecSuccess;\n}\n```\n<p>\n**文章到此就结束了，希望大家能够喜欢。请点击[Git](https://github.com/PanXianyue/XYCryption)获取相关demo**","source":"_posts/RSA-SHA.md","raw":"---\ntitle: 一篇搞定RSA加密与SHA签名\ndate: 2016-01-12 17:19:25\ncategories: iOS\ntags: [RSA加密, SHA签名]\n---\n\n看到这篇文章的同学可幸福了，当时在做RSA加密与签名的时候网上的资料简直不要太老，做完后实在是忍受不下去了，这篇文章我会详细讲解iOS如何实现RSA加密与签名，并且与Java完全同步。\n<!--more-->\n\n# 基础知识 \n\n <p>\n\n1. **什么是RSA？**<p>\n答：RSA是一种非对称加密算法，常用来对传输数据进行加密，配合上数字摘要算法，也可以进行文字签名。\n\n2. **RSA加密中padding？**<p>\n答：padding即填充方式，由于RSA加密算法中要加密的明文是要比模数小的，padding就是通过一些填充方式来限制明文的长度。后面会详细介绍padding的几种模式以及分段加密。\n\n3. **加密和加签有什么区别？**<p>\n答：加密：公钥放在客户端，并使用公钥对数据进行加密，服务端拿到数据后用私钥进行解密； \n      加签：私钥放在客户端，并使用私钥对数据进行加签，服务端拿到数据后用公钥进行验签。       \n前者完全为了加密；后者主要是为了防恶意攻击，防止别人模拟我们的客户端对我们的服务器进行攻击，导致服务器瘫痪。\n\n# 基本原理<p>\n\nRSA使用“密钥对”对数据进行加密解密，在加密解密前需要先生存公钥（Public Key）和私钥（Private Key）。<p>\n**公钥(Public key):** 用于加密数据. 用于公开, 一般存放在数据提供方, 例如iOS客户端。<p>\n**私钥(Private key):** 用于解密数据. 必须保密, 私钥泄露会造成安全问题。<p>\niOS中的Security.framework提供了对RSA算法的支持，这种方式需要对密匙对进行处理, 根据public key生成证书, 通过private key生成p12格式的密匙。想想jave直接用字符串进行加密解密简单多了。(⊙o⊙)…\n\n# 实战\n<p>\n## 证书生成\nRSA加密这块公钥、私钥必不可少的。**Apple是不支持直接使用字符串进行加密解密的，推荐使用p12文件**。这边教大家去生成在加密中使用到的所有文件，并提供给Java使用，想当年这个公钥私钥搞了半天了。 %>_<%\n\n>* 生成模长为1024bit的私钥\nopenssl genrsa -out private_key.pem 1024\n* 生成certification require file\nopenssl req -new -key private_key.pem -out rsaCertReq.csr \n* 生成certification 并指定过期时间\nopenssl x509 -req -days3650-in rsaCertReq.csr -signkey private_key.pem -out rsaCert.crt\n* 生成公钥供iOS使用\nopenssl x509 -outform der -in rsaCert.crt -out public_key.der\n* 生成私钥供iOS使用 这边会让你输入密码，后期用到在生成secKeyRef的时候会用到这个密码\nopenssl pkcs12 -export -out private_key.p12 -inkey private_key.pem -in rsaCert.crt\n* 生成pem结尾的公钥供Java使用\nopenssl rsa -in private_key.pem -out rsa_public_key.pem -pubout\n* 生成pem结尾的私钥供Java使用openssl pkcs8 -topk8 -in private_key.pem -out pkcs8_private_key.pem -nocrypt\n\n**以上所有的步骤都是在终端下完成的哦  (*^__^*)**\n\n## 生成公钥和私钥的secKeyRef<p>\n   ```\n   //根据你的p12文件生成私钥对应的SecKeyRef 这边返回若是nil 请检查你p12文件的生成步骤\n- (SecKeyRef)getPrivateKeyRefrenceFromData:(NSData*)p12Data password:(NSString*)password {\n\nSecKeyRef privateKeyRef = NULL;\nNSMutableDictionary * options = [[NSMutableDictionary alloc] init];\n[options setObject: password forKey:(__bridge id)kSecImportExportPassphrase];\nCFArrayRef items = CFArrayCreate(NULL, 0, 0, NULL);\nOSStatus securityError = SecPKCS12Import((__bridge CFDataRef) p12Data, (__bridge CFDictionaryRef)options, &items);\nif (securityError == noErr && CFArrayGetCount(items) > 0) {\n    CFDictionaryRef identityDict = CFArrayGetValueAtIndex(items, 0);\n    SecIdentityRef identityApp = (SecIdentityRef)CFDictionaryGetValue(identityDict, kSecImportItemIdentity);\n    securityError = SecIdentityCopyPrivateKey(identityApp, &privateKeyRef);\n    if (securityError != noErr) {\n        privateKeyRef = NULL;\n    }\n}\nCFRelease(items);\n\nreturn privateKeyRef;\n}  \n   ```\n   \n   \n   ```\n    //根据你的der文件公钥对应的SecKeyRef\n - (SecKeyRef)getPublicKeyRefrenceFromeData:    (NSData*)derData {\n\nSecCertificateRef myCertificate = SecCertificateCreateWithData(kCFAllocatorDefault, (__bridge CFDataRef)derData);\nSecPolicyRef myPolicy = SecPolicyCreateBasicX509();\nSecTrustRef myTrust;\nOSStatus status = SecTrustCreateWithCertificates(myCertificate,myPolicy,&myTrust);\nSecTrustResultType trustResult;\nif (status == noErr) {\n    status = SecTrustEvaluate(myTrust, &trustResult);\n}\nSecKeyRef securityKey = SecTrustCopyPublicKey(myTrust);\nCFRelease(myCertificate);\nCFRelease(myPolicy);\nCFRelease(myTrust);\n\nreturn securityKey;\n}\n   ```\n   \n## 加密与解密 <p>\n \n ```\n - (NSData*)rsaEncryptData:(NSData*)data {\n    SecKeyRef key = [self getPublicKey];\n    size_t cipherBufferSize = SecKeyGetBlockSize(key);\n    uint8_t *cipherBuffer = malloc(cipherBufferSize * sizeof(uint8_t));\n    size_t blockSize = cipherBufferSize - 11;\n      size_t blockCount = (size_t)ceil([data length] / (double)blockSize);\n      NSMutableData *encryptedData = [[NSMutableData alloc] init];\n    for (int i=0; i<blockCount; i++) {\n    unsigned long bufferSize = MIN(blockSize , [data length] - i * blockSize);\n    NSData *buffer = [data subdataWithRange:NSMakeRange(i * blockSize, bufferSize)];\n    OSStatus status = SecKeyEncrypt(key, kSecPaddingPKCS1, (const uint8_t *)[buffer bytes], [buffer length], cipherBuffer, &cipherBufferSize);\n\n    if (status != noErr) {\n        return nil;\n    }\n\n    NSData *encryptedBytes = [[NSData alloc] initWithBytes:(const void *)cipherBuffer length:cipherBufferSize];\n    [encryptedData appendData:encryptedBytes];\n    }\n\n  if (cipherBuffer){\n    free(cipherBuffer);\n  }\n\n  return encryptedData;\n  }\n ```\n \n ```\n - (NSData*)rsaDecryptData:(NSData*)data {\nSecKeyRef key = [self getPrivatKey];\n\nsize_t cipherBufferSize = SecKeyGetBlockSize(key);\nsize_t blockSize = cipherBufferSize;\nsize_t blockCount = (size_t)ceil([data length] / (double)blockSize);\n\nNSMutableData *decryptedData = [[NSMutableData alloc] init];\n\nfor (int i = 0; i < blockCount; i++) {\n    unsigned long bufferSize = MIN(blockSize , [data length] - i * blockSize);\n    NSData *buffer = [data subdataWithRange:NSMakeRange(i * blockSize, bufferSize)];\n\n    size_t cipherLen = [buffer length];\n    void *cipher = malloc(cipherLen);\n    [buffer getBytes:cipher length:cipherLen];\n    size_t plainLen = SecKeyGetBlockSize(key);\n    void *plain = malloc(plainLen);\n\n    OSStatus status = SecKeyDecrypt(key, kSecPaddingPKCS1, cipher, cipherLen, plain, &plainLen);\n\n    if (status != noErr) {\n        return nil;\n    }\n\n    NSData *decryptedBytes = [[NSData alloc] initWithBytes:(const void *)plain length:plainLen];\n    [decryptedData appendData:decryptedBytes];\n}\n\nreturn decryptedData;\n}\n ```\n \n### RSA加密中的Padding \n\n* RSA_PKCS1_PADDING 填充模式，最常用的模式<p>\n要求: 输入：必须 比 RSA 钥模长(modulus) 短至少11个字节, 也就是　RSA_size(rsa) – 11 如果输入的明文过长，必须切割，然后填充。<p>\n输出：和modulus一样长<p>\n根据这个要求，对于1024bit的密钥，block length = 1024/8 – 11 = 117 字节<p>\n\n* RSA_PKCS1_OAEP_PADDING<p>\n输入：RSA_size(rsa) – 41<p>\n输出：和modulus一样长<p>\n\n* RSA_NO_PADDING　　不填充<p>\n输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，　然后填充<p>\n输出：和modulus一样长<p>\n\n## 签名与验证\n\n```\n //对数据进行sha256签名\n- (NSData *)rsaSHA256SignData:(NSData *)plainData {\n      SecKeyRef key = [self getPrivatKey];\n    \n      size_t signedHashBytesSize = SecKeyGetBlockSize(key);\n      uint8_t* signedHashBytes = malloc(signedHashBytesSize);\n      memset(signedHashBytes, 0x0, signedHashBytesSize);\n    \n      size_t hashBytesSize = CC_SHA256_DIGEST_LENGTH;\n      uint8_t* hashBytes = malloc(hashBytesSize);\n      if (!CC_SHA256([plainData bytes], (CC_LONG)[plainData length], hashBytes)) {\n        return nil;\n    }\n    \n           SecKeyRawSign(key,\n                  kSecPaddingPKCS1SHA256,\n                  hashBytes,\n                  hashBytesSize,\n                  signedHashBytes,\n                  &signedHashBytesSize);\n    \n        NSData* signedHash = [NSData dataWithBytes:signedHashBytes\n                                        length:(NSUInteger)signedHashBytesSize];\n    \n        if (hashBytes)\n        free(hashBytes);\n    if (signedHashBytes)\n        free(signedHashBytes);\n    \n        return signedHash;\n}\n        \n```\n\n\n```\n\n//这边对签名的数据进行验证 验签成功，则返回YES\n- (BOOL)rsaSHA256VerifyData:(NSData *)plainData     withSignature:(NSData *)signature {\n        SecKeyRef key = [self getPublicKey];\n  \n        size_t signedHashBytesSize = SecKeyGetBlockSize(key);\n        const void* signedHashBytes = [signature bytes];\n    \n        size_t hashBytesSize = CC_SHA256_DIGEST_LENGTH;\n        uint8_t* hashBytes = malloc(hashBytesSize);\n        if (!CC_SHA256([plainData bytes], (CC_LONG)[plainData length], hashBytes)) {\n           return NO;\n        }\n    \n          OSStatus status = SecKeyRawVerify(key,\n                                      kSecPaddingPKCS1SHA256,\n                                      hashBytes,\n                                      hashBytesSize,\n                                      signedHashBytes,\n                                      signedHashBytesSize);\n    \n        return status == errSecSuccess;\n}\n```\n<p>\n**文章到此就结束了，希望大家能够喜欢。请点击[Git](https://github.com/PanXianyue/XYCryption)获取相关demo**","slug":"RSA-SHA","published":1,"updated":"2017-01-03T04:28:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiitlufe001855cgjtc5v9b3"},{"title":"Building Faster in Xcode","date":"2018-06-17T12:09:54.000Z","_content":"\nSession 408 \n<!--more-->\n\n![Building Faster in Xcode_](/images/Building%20Faster%20in%20Xcode_.png)\n\n### Parallelizing Your Build\n###### Xcode’s Targets and Dependencies\n\n* Target specifies a product to build\n\t* iOS App \n\t* Framework\n\t* Unit Tests\n* Target dependency requires another target\n\t* Explicit via Target Dependencies \n\t* Implicit via Link Binary with Libraries\n\n###### Game Dependency Graph\n![QQ20180617-164649@2x][image-1]\n\n* List of all targets to build \n* Dependency between targets\n* Build order can be derived\n\n![QQ20180617-165008@2x][image-2]\n\n![QQ20180617-165142@2x][image-3]\n\n* Amount of work did not change \n* Time to build decreased \n* Increased hardware utilization\n\n###### How do we get there?\n* edit scheme\n* build\n* build option\n\t1. Parallelize build\n\t2. Find implicit Dependencies\n\n\n###### Parallelized Target Build Process\n* Compile sources can start earlier\n* Waits only for what it needs \n* Must wait for Run Script phases\n\n### Run Script Phases (Reducing the work on rebuilds)\n> Allows you to customize your build process for your exact needs.\n\n![QQ20180617-174124@2x][image-4]\n\n###### File Lists  \n![QQ20180617-173229@2x][image-5]\n\n* Newline separated\n* Support for build setting variables \n* Cannot be generated during the build\n\n### Measuring Build Time\n###### Build With Timing Summary\n![][image-6]\n\n![][image-7]\n\n\n### Source-Level Improvements\n* Dealing with complex expressions\n* Understanding dependencies in Swift\n* Limiting your Objective-C/Swift interface\n\n###### Turn off Whole Module Mode For Debug Builds\n\n ![][image-8]\n\n###### Use Explicit Types for Complex Properties\n![][image-9]\n\n###### Provide Types in Complex Closures\n\n![][image-10]\n\n###### Break Apart Complex Expressions\n\n![][image-11]\n\n###### Use AnyObject Methods and Properties Sparingly\n\n![][image-12]\n\n调用 `AnyObject` 的方法时, 会去所有的文件中去查找该方法, 编译效率低\n\n解决方案:\n![][image-13]\n通过定义 `protocol`, 然后查找方法就会去此 `protocol` 的声明里面直接去找\n\n\n### Understanding Dependencies in Swift\n###### Incremental Builds Are File-Based\n![][image-14]\n\n![][image-15]\n\n增加方法此时会重新编译\n\n![][image-16]\n\n改变方法的 bodies 不会影响到其他的文件\n\n![][image-17]\n\n不关联的改变在方法外部也会导致重新编译\n\n###### Dependencies Within a Target Are Per-File (目标文件的依赖关系)\n\n![][image-18]\n\n###### Cross-Target Dependencies Are Coarse-Grained\n\n![][image-19]\n\n\n###### Swift Dependency Rules\n* Compiler must be conservative\n* Changes in function bodies do not affect the file’s interface  \n* Dependencies within a module are per-file\n* Dependencies across targets are for the whole target\n\n###### Mixed-Source App Targets\n\n![][image-20]\n\n###### Keep Your Generated Header Minimal\n* Use private when possible\n\n\t```\n\t`@objc private func keyboardWillShow(_: Notification) { // Important keyboard setup code here.\n\t}.\n\t// ...\n\tNotificationCenter.default.addObserver(self, selector: #selector(keyboardWillShow(_:)), ...)\n\t```\n\t* Use block-based APIs\n\n\t```\n\t`self.observer = NotificationCenter.default.addObserver( forName: UIKeyboardWillShow, object: nil, queue: nil) {\n\t// Important keyboard setup code here.\n\t}.\n\t```\n\t* Turn off “Swift 3 @objc Inference”\n\t![][image-21]\n* Keep Your Bridging Header Minimal\n\t* Use categories to break up your interface\n---- \n![][image-22]\n\n### More Information\n> https://developer.apple.com/wwdc18/408\n\n\n\n\n[image-1]:\t/images/QQ20180617-164649@2x.png\n[image-2]:\t/images/QQ20180617-165008@2x.png\n[image-3]:\t/images/QQ20180617-165142@2x.png\n[image-4]:\t/images/QQ20180617-174124@2x.png\n[image-5]:\t/images/QQ20180617-173229@2x.png\n[image-6]:\t/images/15292293472562.jpg\n[image-7]:\t/images/15292295109399.jpg\n[image-8]:\t/images/15292297716350.jpg\n[image-9]:\t/images/15292304002286.jpg\n[image-10]:\t/images/15292304507458.jpg\n[image-11]:\t/images/15292305166448.jpg\n[image-12]:\t/images/15292305743843.jpg\n[image-13]:\t/images/15292308090026.jpg\n[image-14]:\t/images/15292312274443.jpg\n[image-15]:\t/images/15292312680309.jpg\n[image-16]:\t/images/15292313035255.jpg\n[image-17]:\t/images/15292313838157.jpg\n[image-18]:\t/images/15292346436023.jpg\n[image-19]:\t/images/15292346898606.jpg\n[image-20]:\t/images/15292351447821.jpg\n[image-21]:\t/images/15292355397528.jpg\n[image-22]:\t/images/15292356504822.jpg\n\n","source":"_posts/408-building-faster-in-xcode.md","raw":"---\ntitle: Building Faster in Xcode\ndate: 2018-06-17 20:09:54\ntags : [WWDC]\n---\n\nSession 408 \n<!--more-->\n\n![Building Faster in Xcode_](/images/Building%20Faster%20in%20Xcode_.png)\n\n### Parallelizing Your Build\n###### Xcode’s Targets and Dependencies\n\n* Target specifies a product to build\n\t* iOS App \n\t* Framework\n\t* Unit Tests\n* Target dependency requires another target\n\t* Explicit via Target Dependencies \n\t* Implicit via Link Binary with Libraries\n\n###### Game Dependency Graph\n![QQ20180617-164649@2x][image-1]\n\n* List of all targets to build \n* Dependency between targets\n* Build order can be derived\n\n![QQ20180617-165008@2x][image-2]\n\n![QQ20180617-165142@2x][image-3]\n\n* Amount of work did not change \n* Time to build decreased \n* Increased hardware utilization\n\n###### How do we get there?\n* edit scheme\n* build\n* build option\n\t1. Parallelize build\n\t2. Find implicit Dependencies\n\n\n###### Parallelized Target Build Process\n* Compile sources can start earlier\n* Waits only for what it needs \n* Must wait for Run Script phases\n\n### Run Script Phases (Reducing the work on rebuilds)\n> Allows you to customize your build process for your exact needs.\n\n![QQ20180617-174124@2x][image-4]\n\n###### File Lists  \n![QQ20180617-173229@2x][image-5]\n\n* Newline separated\n* Support for build setting variables \n* Cannot be generated during the build\n\n### Measuring Build Time\n###### Build With Timing Summary\n![][image-6]\n\n![][image-7]\n\n\n### Source-Level Improvements\n* Dealing with complex expressions\n* Understanding dependencies in Swift\n* Limiting your Objective-C/Swift interface\n\n###### Turn off Whole Module Mode For Debug Builds\n\n ![][image-8]\n\n###### Use Explicit Types for Complex Properties\n![][image-9]\n\n###### Provide Types in Complex Closures\n\n![][image-10]\n\n###### Break Apart Complex Expressions\n\n![][image-11]\n\n###### Use AnyObject Methods and Properties Sparingly\n\n![][image-12]\n\n调用 `AnyObject` 的方法时, 会去所有的文件中去查找该方法, 编译效率低\n\n解决方案:\n![][image-13]\n通过定义 `protocol`, 然后查找方法就会去此 `protocol` 的声明里面直接去找\n\n\n### Understanding Dependencies in Swift\n###### Incremental Builds Are File-Based\n![][image-14]\n\n![][image-15]\n\n增加方法此时会重新编译\n\n![][image-16]\n\n改变方法的 bodies 不会影响到其他的文件\n\n![][image-17]\n\n不关联的改变在方法外部也会导致重新编译\n\n###### Dependencies Within a Target Are Per-File (目标文件的依赖关系)\n\n![][image-18]\n\n###### Cross-Target Dependencies Are Coarse-Grained\n\n![][image-19]\n\n\n###### Swift Dependency Rules\n* Compiler must be conservative\n* Changes in function bodies do not affect the file’s interface  \n* Dependencies within a module are per-file\n* Dependencies across targets are for the whole target\n\n###### Mixed-Source App Targets\n\n![][image-20]\n\n###### Keep Your Generated Header Minimal\n* Use private when possible\n\n\t```\n\t`@objc private func keyboardWillShow(_: Notification) { // Important keyboard setup code here.\n\t}.\n\t// ...\n\tNotificationCenter.default.addObserver(self, selector: #selector(keyboardWillShow(_:)), ...)\n\t```\n\t* Use block-based APIs\n\n\t```\n\t`self.observer = NotificationCenter.default.addObserver( forName: UIKeyboardWillShow, object: nil, queue: nil) {\n\t// Important keyboard setup code here.\n\t}.\n\t```\n\t* Turn off “Swift 3 @objc Inference”\n\t![][image-21]\n* Keep Your Bridging Header Minimal\n\t* Use categories to break up your interface\n---- \n![][image-22]\n\n### More Information\n> https://developer.apple.com/wwdc18/408\n\n\n\n\n[image-1]:\t/images/QQ20180617-164649@2x.png\n[image-2]:\t/images/QQ20180617-165008@2x.png\n[image-3]:\t/images/QQ20180617-165142@2x.png\n[image-4]:\t/images/QQ20180617-174124@2x.png\n[image-5]:\t/images/QQ20180617-173229@2x.png\n[image-6]:\t/images/15292293472562.jpg\n[image-7]:\t/images/15292295109399.jpg\n[image-8]:\t/images/15292297716350.jpg\n[image-9]:\t/images/15292304002286.jpg\n[image-10]:\t/images/15292304507458.jpg\n[image-11]:\t/images/15292305166448.jpg\n[image-12]:\t/images/15292305743843.jpg\n[image-13]:\t/images/15292308090026.jpg\n[image-14]:\t/images/15292312274443.jpg\n[image-15]:\t/images/15292312680309.jpg\n[image-16]:\t/images/15292313035255.jpg\n[image-17]:\t/images/15292313838157.jpg\n[image-18]:\t/images/15292346436023.jpg\n[image-19]:\t/images/15292346898606.jpg\n[image-20]:\t/images/15292351447821.jpg\n[image-21]:\t/images/15292355397528.jpg\n[image-22]:\t/images/15292356504822.jpg\n\n","slug":"408-building-faster-in-xcode","published":1,"updated":"2018-06-17T12:31:29.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiitlufh001e55cg5o9beff4"}],"PostAsset":[],"PostCategory":[{"post_id":"cjiitluei000555cg5w1v96dh","category_id":"cjiitluek000655cg4rjufc52","_id":"cjiitluen000955cgeezw8avy"},{"post_id":"cjiitluey000l55cg71u0ckei","category_id":"cjiitluek000655cg4rjufc52","_id":"cjiitluf0000m55cgvqvwvfj1"},{"post_id":"cjiitluf3000r55cg8i2v3k13","category_id":"cjiitluek000655cg4rjufc52","_id":"cjiitluf4000s55cg5ystc4im"},{"post_id":"cjiitluf6000w55cgm4ggevrh","category_id":"cjiitluek000655cg4rjufc52","_id":"cjiitluf7000x55cglznwk0q2"},{"post_id":"cjiitlufa001655cgcp8a6urt","category_id":"cjiitluek000655cg4rjufc52","_id":"cjiitlufc001755cgzscjkywq"},{"post_id":"cjiitlufe001855cgjtc5v9b3","category_id":"cjiitluek000655cg4rjufc52","_id":"cjiitluff001955cgcm3xq5z7"}],"PostTag":[{"post_id":"cjiitluei000555cg5w1v96dh","tag_id":"cjiitluek000755cg9vdby8o0","_id":"cjiitlueo000b55cgytnnu0x3"},{"post_id":"cjiitluei000555cg5w1v96dh","tag_id":"cjiitluen000855cgvn5tbeql","_id":"cjiitlueo000c55cgtvd1hh78"},{"post_id":"cjiitluei000555cg5w1v96dh","tag_id":"cjiitlueo000a55cg7nwshbxh","_id":"cjiitlueo000d55cglciooukv"},{"post_id":"cjiitlues000f55cg9a2ws6i4","tag_id":"cjiitluet000g55cgsmhe8ebj","_id":"cjiitluet000h55cgwzu26h2e"},{"post_id":"cjiitluev000i55cghs04ml91","tag_id":"cjiitluev000j55cg06b7xna6","_id":"cjiitluew000k55cgeka9uu1v"},{"post_id":"cjiitluey000l55cg71u0ckei","tag_id":"cjiitluf0000n55cg3pmg75nh","_id":"cjiitluf1000p55cge9xbume6"},{"post_id":"cjiitluey000l55cg71u0ckei","tag_id":"cjiitluf1000o55cg8lzahwq3","_id":"cjiitluf1000q55cgg5gmgvjj"},{"post_id":"cjiitluf3000r55cg8i2v3k13","tag_id":"cjiitluf0000n55cg3pmg75nh","_id":"cjiitluf5000u55cg86aqe0s3"},{"post_id":"cjiitluf3000r55cg8i2v3k13","tag_id":"cjiitluf4000t55cgohpgevg3","_id":"cjiitluf5000v55cgeb6uff3n"},{"post_id":"cjiitluf6000w55cgm4ggevrh","tag_id":"cjiitluf8000y55cgrp7sfbw4","_id":"cjiitluf9001255cgtb15mss4"},{"post_id":"cjiitluf6000w55cgm4ggevrh","tag_id":"cjiitluf8000z55cg5bxu48fi","_id":"cjiitluf9001355cgwu5lbxre"},{"post_id":"cjiitluf6000w55cgm4ggevrh","tag_id":"cjiitluf8001055cgmugv3sly","_id":"cjiitluf9001455cg2k7eojpm"},{"post_id":"cjiitluf6000w55cgm4ggevrh","tag_id":"cjiitluf8001155cgobp8ppnu","_id":"cjiitluf9001555cg4kayumyg"},{"post_id":"cjiitlufe001855cgjtc5v9b3","tag_id":"cjiitluff001a55cgp11cb45b","_id":"cjiitlufg001c55cgobmnlm3o"},{"post_id":"cjiitlufe001855cgjtc5v9b3","tag_id":"cjiitluff001b55cgvyiq21kj","_id":"cjiitlufg001d55cg699s0ego"},{"post_id":"cjiitlufh001e55cg5o9beff4","tag_id":"cjiitlufh001f55cgypmuyofx","_id":"cjiitlufi001g55cgm0bl27hz"}],"Tag":[{"name":"XCTOOL","_id":"cjiitluek000755cg9vdby8o0"},{"name":"SHELL","_id":"cjiitluen000855cgvn5tbeql"},{"name":"LINUX命令","_id":"cjiitlueo000a55cg7nwshbxh"},{"name":"GIT","_id":"cjiitluet000g55cgsmhe8ebj"},{"name":"Tool","_id":"cjiitluev000j55cg06b7xna6"},{"name":"YYKit","_id":"cjiitluf0000n55cg3pmg75nh"},{"name":"pthread","_id":"cjiitluf1000o55cg8lzahwq3"},{"name":"YYCache","_id":"cjiitluf4000t55cgohpgevg3"},{"name":"SOCKET","_id":"cjiitluf8000y55cgrp7sfbw4"},{"name":"HTTP","_id":"cjiitluf8000z55cg5bxu48fi"},{"name":"TCP","_id":"cjiitluf8001055cgmugv3sly"},{"name":"UDP","_id":"cjiitluf8001155cgobp8ppnu"},{"name":"RSA加密","_id":"cjiitluff001a55cgp11cb45b"},{"name":"SHA签名","_id":"cjiitluff001b55cgvyiq21kj"},{"name":"WWDC","_id":"cjiitlufh001f55cgypmuyofx"}]}}