{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":0},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":0},{"_id":"themes/apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":0},{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":0},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":0},{"_id":"themes/apollo/source/avatar2.jpg","path":"avatar2.jpg","modified":0},{"_id":"themes/apollo/source/avatar1.jpg","path":"avatar1.jpg","modified":0},{"_id":"themes/apollo/source/avatar.jpg","path":"avatar.jpg","modified":0},{"_id":"source/CNAME","path":"CNAME","modified":1}],"Cache":[{"_id":"source/_posts/Socket.md","shasum":"c765fb52da056befb6ba062fae3a9d3d9db119d4","modified":1472097032000},{"_id":"source/_posts/RSA-SHA.md","shasum":"421b13651b5adb305a43bd2f200397a05c7d212b","modified":1472097076000},{"_id":"source/_posts/Runtime-tabBarItem.md","shasum":"28a23b2719daf90bbf83e081322e4bc4c2dd2102","modified":1472130743000},{"_id":"source/_posts/Summary.md","shasum":"27a5ca7c563a1fe8213c0c3823d26f95f4e00fe0","modified":1472099335000},{"_id":"source/_posts/sketch-makeicons.md","shasum":"5ada769f420a87c13c1afe220922676e09ff6c0c","modified":1477379819000},{"_id":"source/_posts/YYCache-analyzing.md","shasum":"791644c72e2bb437ca279b1598510374dbb2c1dc","modified":1472096784000},{"_id":"source/_posts/YYKit-pthread.md","shasum":"411fad792112b8b25ed9d6eaf3e21c027f24d3f2","modified":1472096900000},{"_id":"source/_posts/xctool-package.md","shasum":"add599511f6d00f3d8031a2f3f75684ec1093a6a","modified":1472109930000},{"_id":"source/_posts/执着.md","shasum":"7daa87a86c5d59312293588c3f9a49d2e12a2c57","modified":1472131119000},{"_id":"source/about/index.md","shasum":"f659e89ebbd7d656208371abfca5401de89e1e09","modified":1452924437000},{"_id":"source/categories/index.md","shasum":"283a947e797500aa6f9398ecfdcce410670b9a2d","modified":1452924164000},{"_id":"source/tags/index.md","shasum":"b5a8983835c5e8b3f6b50413ef22f325c4e75f35","modified":1452924126000},{"_id":"source/instagram/index.md","shasum":"ce39a108289ee00c6c55d4c50e628f99bc26de18","modified":1452920289000},{"_id":"source/uploads/avatar.jpg","shasum":"cd576a77b0e3fc0cd4bda8f35afc9a23755a890d","modified":1452919442000},{"_id":"themes/apollo/LICENSE","shasum":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1460861213000},{"_id":"themes/apollo/_config.yml","shasum":"f1d158863424415031900df2d3c6a72f1af8b096","modified":1472109690000},{"_id":"themes/apollo/README.md","shasum":"fb6fbe42172a35cbdaa540a777cc4bc02add2278","modified":1472093882000},{"_id":"themes/apollo/doc/doc-en.md","shasum":"d6d9756b2085cdd8ee51eb5594427e2abf170e94","modified":1460861213000},{"_id":"themes/apollo/doc/doc-zh.md","shasum":"d43c1f6bff66426744a2c6f031d19ff09cdeb2d1","modified":1460861213000},{"_id":"themes/apollo/languages/en.yml","shasum":"40292f2a48e4e6361132033a47c516cb33127b6c","modified":1460861213000},{"_id":"themes/apollo/gulpfile.js","shasum":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1460861213000},{"_id":"themes/apollo/layout/archive.jade","shasum":"62797414355bf4474092bc3a32726c8340820ffb","modified":1460861213000},{"_id":"themes/apollo/languages/zh-cn.yml","shasum":"9e4b03e14c094000257ea254fd660dde4c7af63c","modified":1460861213000},{"_id":"themes/apollo/layout/index.jade","shasum":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1460861213000},{"_id":"themes/apollo/layout/partial/comment.jade","shasum":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1460861213000},{"_id":"themes/apollo/layout/mixins/paginator.jade","shasum":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1460861213000},{"_id":"themes/apollo/layout/mixins/post.jade","shasum":"cd9447e9b0ad22213e6a17d9a9b948f9f998f921","modified":1462975735000},{"_id":"themes/apollo/layout/partial/copyright.jade","shasum":"217f8b17054e5079f2d30bb7e2e4e36c0f2161b7","modified":1472093882000},{"_id":"themes/apollo/layout/partial/head.jade","shasum":"d062dafabfe65198e5cf2ddb0e47d909885aa950","modified":1472093882000},{"_id":"themes/apollo/layout/partial/layout.jade","shasum":"eb15573ff66bdbb110ac77cf360b740170cee738","modified":1462975735000},{"_id":"themes/apollo/layout/partial/nav.jade","shasum":"c35d3061da4b053b73150d9741c542d660798270","modified":1460861213000},{"_id":"themes/apollo/layout/post.jade","shasum":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1462975735000},{"_id":"themes/apollo/layout/partial/scripts.jade","shasum":"cf3339de8979b5f75a3011f0f6b5451091b77dc8","modified":1472093882000},{"_id":"themes/apollo/package.json","shasum":"4d13f5f859db7d008f49251543a8f610b2ecabd5","modified":1472093882000},{"_id":"themes/apollo/source/_avatar.jpg","shasum":"cd576a77b0e3fc0cd4bda8f35afc9a23755a890d","modified":1472093983000},{"_id":"themes/apollo/source/avatar.jpg","shasum":"b22e7fed252896bf3f7d3fa0e63b889b8fbf5311","modified":1472133412000},{"_id":"themes/apollo/source/avatar1.jpg","shasum":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1472093983000},{"_id":"themes/apollo/source/css/apollo.css","shasum":"2cfd049bcbad8a9a68c13299a92e993d5c92d029","modified":1472093882000},{"_id":"themes/apollo/source/favicon.png","shasum":"bd1854baae82d46b0d96212c1bedca1313056383","modified":1472100967000},{"_id":"themes/apollo/source/font/sourcesanspro.woff","shasum":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1472093882000},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","shasum":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1472093882000},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","shasum":"d2f740a7d48349b7536777c795f82ab740836d0f","modified":1462975735000},{"_id":"themes/apollo/source/scss/_partial/base.scss","shasum":"fe20c16c18ab76b843d0aab2e1a5cc4f5d6d64c7","modified":1472093882000},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","shasum":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1462975735000},{"_id":"themes/apollo/source/scss/_partial/footer.scss","shasum":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1460861213000},{"_id":"themes/apollo/source/scss/_partial/header.scss","shasum":"153bde88bf8ffeae4ffd813d8cc694dd83d33d94","modified":1460861213000},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","shasum":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1462975735000},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","shasum":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1460861213000},{"_id":"themes/apollo/source/scss/_partial/mq.scss","shasum":"b5eb0fb35fb275cbb6452b5d98702d461af3e6d5","modified":1460861213000},{"_id":"themes/apollo/source/scss/_partial/post.scss","shasum":"ae780828148f79e5069b480e3576f1fea1246866","modified":1472093882000},{"_id":"themes/apollo/source/scss/apollo.scss","shasum":"153bbf882c1f6f65bb4510999b51812e20016ca7","modified":1472093882000},{"_id":"themes/apollo/source/avatar2.jpg","shasum":"0555d723637c4da77dbe6722d26f262802d1dcd0","modified":1472093983000},{"_id":"public/uploads/avatar.jpg","modified":1477380179873,"shasum":"cd576a77b0e3fc0cd4bda8f35afc9a23755a890d"},{"_id":"public/scss/apollo.scss","modified":1477380179879,"shasum":"153bbf882c1f6f65bb4510999b51812e20016ca7"},{"_id":"public/font/sourcesanspro.woff2","modified":1477380179883,"shasum":"da65f527a8da65d5eb6721626d28cfdb46ab104a"},{"_id":"public/font/sourcesanspro.woff","modified":1477380179888,"shasum":"a6722c9b6439b7a020a9be3d3178970757a9265c"},{"_id":"public/favicon.png","modified":1477380179891,"shasum":"bd1854baae82d46b0d96212c1bedca1313056383"},{"_id":"public/css/apollo.css","modified":1477380179897,"shasum":"2cfd049bcbad8a9a68c13299a92e993d5c92d029"},{"_id":"public/avatar2.jpg","modified":1477380179902,"shasum":"0555d723637c4da77dbe6722d26f262802d1dcd0"},{"_id":"public/avatar1.jpg","modified":1477380179907,"shasum":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c"},{"_id":"public/avatar.jpg","modified":1477380179911,"shasum":"b22e7fed252896bf3f7d3fa0e63b889b8fbf5311"},{"_id":"public/tags/index.html","modified":1477380180185,"shasum":"c7c117a26abb1571e1359d2f0ff5aea51ef91262"},{"_id":"public/instagram/index.html","modified":1477380180378,"shasum":"94acfd6b1e20f4f3cfba433c9daa06209993d797"},{"_id":"public/categories/index.html","modified":1477380180547,"shasum":"071acd68ba8e12bb0bc31b21f56323c91b3d8895"},{"_id":"public/about/index.html","modified":1477380180682,"shasum":"a2c6cc4f786c88baa325e1cd4b60342d786bc528"},{"_id":"public/2016/09/26/sketch-makeicons/index.html","modified":1477380180822,"shasum":"94439fa6c083a699f628bf370d522fa724c6fa1a"},{"_id":"public/2016/08/25/执着/index.html","modified":1477380180927,"shasum":"5f912b311d0f97e4d7fe707e58404434298409e6"},{"_id":"public/2016/07/18/YYCache-analyzing/index.html","modified":1477380180993,"shasum":"eee62eb619e7dfa331e1593e6b1c9e41a3caf310"},{"_id":"public/2016/06/21/YYKit-pthread/index.html","modified":1477380181038,"shasum":"4fa71539476dfbec914644cb5a481589729086cb"},{"_id":"public/2016/05/11/Runtime-tabBarItem/index.html","modified":1477380181092,"shasum":"eb8e8adb7abfcd40db4a94f52c32896aca1238b8"},{"_id":"public/2016/02/13/xctool-package/index.html","modified":1477380181141,"shasum":"4da9d9bfe0d8008b343ffe5f4551e5ab798a541c"},{"_id":"public/2016/01/17/Summary/index.html","modified":1477380181212,"shasum":"0eeadeba03390a73c90ff7c55cb7af8567db8cb1"},{"_id":"public/2016/01/16/Socket/index.html","modified":1477380181291,"shasum":"95dc3c0a84e45ecff17d049e995b6f37832cad2a"},{"_id":"public/2016/01/12/RSA-SHA/index.html","modified":1477380181347,"shasum":"7f24d57df0297eed7782214978ac6b0074e83ca6"},{"_id":"public/archives/index.html","modified":1477380181433,"shasum":"5b57259930348f0272769f7d5e0d624ca20d5466"},{"_id":"public/archives/2016/index.html","modified":1477380181509,"shasum":"5b57259930348f0272769f7d5e0d624ca20d5466"},{"_id":"public/archives/2016/01/index.html","modified":1477380181550,"shasum":"52c99488615a3beb4538ee82f7369d09c0e183a0"},{"_id":"public/archives/2016/02/index.html","modified":1477380181593,"shasum":"71c8aaca51312d941ea62f58a083390313d41ea4"},{"_id":"public/archives/2016/05/index.html","modified":1477380181639,"shasum":"80cd9a133241a1fa9aa5a1464b94006e3603f8d9"},{"_id":"public/archives/2016/06/index.html","modified":1477380181695,"shasum":"2c9580f18a5679fa3cc0b5c344e7b8ff48213c0b"},{"_id":"public/archives/2016/07/index.html","modified":1477380181745,"shasum":"ac2de8f7f1acfd47728d5b32817fe1b390a07bf8"},{"_id":"public/archives/2016/08/index.html","modified":1477380181797,"shasum":"f6b76bdde5d54d38fcbe7c5f5d94aeffae36fd85"},{"_id":"public/archives/2016/09/index.html","modified":1477380181851,"shasum":"1db463b5fdee93b0eaf654c72e7812a1c6e955b0"},{"_id":"public/categories/iOS/index.html","modified":1477380181904,"shasum":"d2760a70ea9b42336961741eaf1a82e24983db35"},{"_id":"public/categories/life/index.html","modified":1477380181956,"shasum":"d63bda97d0e128dde7f7ce9820d98704fe3eb079"},{"_id":"public/atom.xml","modified":1477380181960,"shasum":"cb56c460ebfc31fb39c303629bb2d02ae97c25c1"},{"_id":"public/index.html","modified":1477380182023,"shasum":"25ba52e47a9c8d1fb8e610425a396053d301b5f5"},{"_id":"public/sitemap.xml","modified":1477380182025,"shasum":"a864b9e0f49cea9340c158b0d28e10a60ae9db84"},{"_id":"public/tags/RSA加密/index.html","modified":1477380182065,"shasum":"d60b5842e968b17ecf0edb599c2a88734af6a699"},{"_id":"public/tags/SHA签名/index.html","modified":1477380182122,"shasum":"d60b5842e968b17ecf0edb599c2a88734af6a699"},{"_id":"public/tags/XCTOOL/index.html","modified":1477380182173,"shasum":"71c8aaca51312d941ea62f58a083390313d41ea4"},{"_id":"public/tags/SHELL/index.html","modified":1477380182223,"shasum":"71c8aaca51312d941ea62f58a083390313d41ea4"},{"_id":"public/tags/LINUX命令/index.html","modified":1477380182377,"shasum":"71c8aaca51312d941ea62f58a083390313d41ea4"},{"_id":"public/tags/YYKit/index.html","modified":1477380182537,"shasum":"e32062e8d9acdcb13f54b9cc4238a6a102537300"},{"_id":"public/tags/pthread/index.html","modified":1477380182602,"shasum":"2c9580f18a5679fa3cc0b5c344e7b8ff48213c0b"},{"_id":"public/tags/YYCache/index.html","modified":1477380182704,"shasum":"ac2de8f7f1acfd47728d5b32817fe1b390a07bf8"},{"_id":"public/tags/SOCKET/index.html","modified":1477380182755,"shasum":"70063d2965f270c5be18c38b9f95a7052e8f2366"},{"_id":"public/tags/HTTP/index.html","modified":1477380182797,"shasum":"70063d2965f270c5be18c38b9f95a7052e8f2366"},{"_id":"public/tags/TCP/index.html","modified":1477380182850,"shasum":"70063d2965f270c5be18c38b9f95a7052e8f2366"},{"_id":"public/tags/UDP/index.html","modified":1477380182903,"shasum":"70063d2965f270c5be18c38b9f95a7052e8f2366"},{"_id":"source/CNAME","shasum":"cf3446bacd3f04cf9f93fc86cd2af1c9edfbfeba","modified":1479452925000},{"_id":"public/CNAME","modified":1479453023680,"shasum":"cf3446bacd3f04cf9f93fc86cd2af1c9edfbfeba"}],"Category":[{"name":"iOS","_id":"ciup60i1j0001tlch3ac9czp8"},{"name":"life","_id":"ciup60i2j000xtlchdaq92akx"}],"Data":[],"Page":[{"title":"tags","date":"2016-01-16T06:00:56.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-01-16 14:00:56\ntype: \"tags\"\n---\n","updated":"2016-01-16T06:02:06.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ciup60i1v0007tlchtwsydvlu"},{"layout":"post","slug":"instagram","title":"相册","noDate":"true","_content":"\n<div class=\"instagram\" data-client-id=\"119e030b1722460e96852704153c0d16\" data-user-id=\"1260660358\">\n    <a href=\"http://instagram.com/panxianyue\" target=\"_blank\" class=\"open-ins\">图片来自instagram，正在加载中…</a>\n</div>\n<script src=\"/js/jquery.lazyload.js\"></script>\n<script src=\"/js/instagram.js\"></script>","source":"instagram/index.md","raw":"---\nlayout: post\nslug: \"instagram\"\ntitle: \"相册\"\nnoDate: \"true\"\n---\n\n<div class=\"instagram\" data-client-id=\"119e030b1722460e96852704153c0d16\" data-user-id=\"1260660358\">\n    <a href=\"http://instagram.com/panxianyue\" target=\"_blank\" class=\"open-ins\">图片来自instagram，正在加载中…</a>\n</div>\n<script src=\"/js/jquery.lazyload.js\"></script>\n<script src=\"/js/instagram.js\"></script>","date":"2016-09-28T01:46:05.000Z","updated":"2016-01-16T04:58:09.000Z","path":"instagram/index.html","comments":1,"_id":"ciup60i1y0008tlchrauhdb0b"},{"title":"categories","date":"2016-01-16T06:02:26.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-01-16 14:02:26\ntype: \"categories\"\n---\n","updated":"2016-01-16T06:02:44.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ciup60i1z0009tlch2fl6l91e"},{"title":"about","date":"2016-01-16T06:07:17.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-01-16 14:07:17\n---\n","updated":"2016-01-16T06:07:17.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ciup60i20000atlch5kpzl7yg"}],"Post":[{"title":"一篇搞定RSA加密与SHA签名","date":"2016-01-12T09:19:25.000Z","_content":"\n看到这篇文章的同学可幸福了，当时在做RSA加密与签名的时候网上的资料简直不要太老，做完后实在是忍受不下去了，这篇文章我会详细讲解iOS如何实现RSA加密与签名，并且与Java完全同步。\n<!--more-->\n\n# 基础知识 \n\n <p>\n\n1. **什么是RSA？**<p>\n答：RSA是一种非对称加密算法，常用来对传输数据进行加密，配合上数字摘要算法，也可以进行文字签名。\n\n2. **RSA加密中padding？**<p>\n答：padding即填充方式，由于RSA加密算法中要加密的明文是要比模数小的，padding就是通过一些填充方式来限制明文的长度。后面会详细介绍padding的几种模式以及分段加密。\n\n3. **加密和加签有什么区别？**<p>\n答：加密：公钥放在客户端，并使用公钥对数据进行加密，服务端拿到数据后用私钥进行解密； \n      加签：私钥放在客户端，并使用私钥对数据进行加签，服务端拿到数据后用公钥进行验签。       \n前者完全为了加密；后者主要是为了防恶意攻击，防止别人模拟我们的客户端对我们的服务器进行攻击，导致服务器瘫痪。\n\n# 基本原理<p>\n\nRSA使用“密钥对”对数据进行加密解密，在加密解密前需要先生存公钥（Public Key）和私钥（Private Key）。<p>\n**公钥(Public key):** 用于加密数据. 用于公开, 一般存放在数据提供方, 例如iOS客户端。<p>\n**私钥(Private key):** 用于解密数据. 必须保密, 私钥泄露会造成安全问题。<p>\niOS中的Security.framework提供了对RSA算法的支持，这种方式需要对密匙对进行处理, 根据public key生成证书, 通过private key生成p12格式的密匙。想想jave直接用字符串进行加密解密简单多了。(⊙o⊙)…\n\n# 实战\n<p>\n## 证书生成\nRSA加密这块公钥、私钥必不可少的。**Apple是不支持直接使用字符串进行加密解密的，推荐使用p12文件**。这边教大家去生成在加密中使用到的所有文件，并提供给Java使用，想当年这个公钥私钥搞了半天了。 %>_<%\n\n>* 生成模长为1024bit的私钥\nopenssl genrsa -out private_key.pem 1024\n* 生成certification require file\nopenssl req -new -key private_key.pem -out rsaCertReq.csr \n* 生成certification 并指定过期时间\nopenssl x509 -req -days3650-in rsaCertReq.csr -signkey private_key.pem -out rsaCert.crt\n* 生成公钥供iOS使用\nopenssl x509 -outform der -in rsaCert.crt -out public_key.der\n* 生成私钥供iOS使用 这边会让你输入密码，后期用到在生成secKeyRef的时候会用到这个密码\nopenssl pkcs12 -export -out private_key.p12 -inkey private_key.pem -in rsaCert.crt\n* 生成pem结尾的公钥供Java使用\nopenssl rsa -in private_key.pem -out rsa_public_key.pem -pubout\n* 生成pem结尾的私钥供Java使用openssl pkcs8 -topk8 -in private_key.pem -out pkcs8_private_key.pem -nocrypt\n\n**以上所有的步骤都是在终端下完成的哦  (*^__^*)**\n\n## 生成公钥和私钥的secKeyRef<p>\n   ```\n   //根据你的p12文件生成私钥对应的SecKeyRef 这边返回若是nil 请检查你p12文件的生成步骤\n- (SecKeyRef)getPrivateKeyRefrenceFromData:(NSData*)p12Data password:(NSString*)password {\n\nSecKeyRef privateKeyRef = NULL;\nNSMutableDictionary * options = [[NSMutableDictionary alloc] init];\n[options setObject: password forKey:(__bridge id)kSecImportExportPassphrase];\nCFArrayRef items = CFArrayCreate(NULL, 0, 0, NULL);\nOSStatus securityError = SecPKCS12Import((__bridge CFDataRef) p12Data, (__bridge CFDictionaryRef)options, &items);\nif (securityError == noErr && CFArrayGetCount(items) > 0) {\n    CFDictionaryRef identityDict = CFArrayGetValueAtIndex(items, 0);\n    SecIdentityRef identityApp = (SecIdentityRef)CFDictionaryGetValue(identityDict, kSecImportItemIdentity);\n    securityError = SecIdentityCopyPrivateKey(identityApp, &privateKeyRef);\n    if (securityError != noErr) {\n        privateKeyRef = NULL;\n    }\n}\nCFRelease(items);\n\nreturn privateKeyRef;\n}  \n   ```\n   \n   \n   ```\n    //根据你的der文件公钥对应的SecKeyRef\n - (SecKeyRef)getPublicKeyRefrenceFromeData:    (NSData*)derData {\n\nSecCertificateRef myCertificate = SecCertificateCreateWithData(kCFAllocatorDefault, (__bridge CFDataRef)derData);\nSecPolicyRef myPolicy = SecPolicyCreateBasicX509();\nSecTrustRef myTrust;\nOSStatus status = SecTrustCreateWithCertificates(myCertificate,myPolicy,&myTrust);\nSecTrustResultType trustResult;\nif (status == noErr) {\n    status = SecTrustEvaluate(myTrust, &trustResult);\n}\nSecKeyRef securityKey = SecTrustCopyPublicKey(myTrust);\nCFRelease(myCertificate);\nCFRelease(myPolicy);\nCFRelease(myTrust);\n\nreturn securityKey;\n}\n   ```\n   \n## 加密与解密 <p>\n \n ```\n - (NSData*)rsaEncryptData:(NSData*)data {\n    SecKeyRef key = [self getPublicKey];\n    size_t cipherBufferSize = SecKeyGetBlockSize(key);\n    uint8_t *cipherBuffer = malloc(cipherBufferSize * sizeof(uint8_t));\n    size_t blockSize = cipherBufferSize - 11;\n      size_t blockCount = (size_t)ceil([data length] / (double)blockSize);\n      NSMutableData *encryptedData = [[NSMutableData alloc] init];\n    for (int i=0; i<blockCount; i++) {\n    unsigned long bufferSize = MIN(blockSize , [data length] - i * blockSize);\n    NSData *buffer = [data subdataWithRange:NSMakeRange(i * blockSize, bufferSize)];\n    OSStatus status = SecKeyEncrypt(key, kSecPaddingPKCS1, (const uint8_t *)[buffer bytes], [buffer length], cipherBuffer, &cipherBufferSize);\n\n    if (status != noErr) {\n        return nil;\n    }\n\n    NSData *encryptedBytes = [[NSData alloc] initWithBytes:(const void *)cipherBuffer length:cipherBufferSize];\n    [encryptedData appendData:encryptedBytes];\n    }\n\n  if (cipherBuffer){\n    free(cipherBuffer);\n  }\n\n  return encryptedData;\n  }\n ```\n \n ```\n - (NSData*)rsaDecryptData:(NSData*)data {\nSecKeyRef key = [self getPrivatKey];\n\nsize_t cipherBufferSize = SecKeyGetBlockSize(key);\nsize_t blockSize = cipherBufferSize;\nsize_t blockCount = (size_t)ceil([data length] / (double)blockSize);\n\nNSMutableData *decryptedData = [[NSMutableData alloc] init];\n\nfor (int i = 0; i < blockCount; i++) {\n    unsigned long bufferSize = MIN(blockSize , [data length] - i * blockSize);\n    NSData *buffer = [data subdataWithRange:NSMakeRange(i * blockSize, bufferSize)];\n\n    size_t cipherLen = [buffer length];\n    void *cipher = malloc(cipherLen);\n    [buffer getBytes:cipher length:cipherLen];\n    size_t plainLen = SecKeyGetBlockSize(key);\n    void *plain = malloc(plainLen);\n\n    OSStatus status = SecKeyDecrypt(key, kSecPaddingPKCS1, cipher, cipherLen, plain, &plainLen);\n\n    if (status != noErr) {\n        return nil;\n    }\n\n    NSData *decryptedBytes = [[NSData alloc] initWithBytes:(const void *)plain length:plainLen];\n    [decryptedData appendData:decryptedBytes];\n}\n\nreturn decryptedData;\n}\n ```\n \n### RSA加密中的Padding \n\n* RSA_PKCS1_PADDING 填充模式，最常用的模式<p>\n要求: 输入：必须 比 RSA 钥模长(modulus) 短至少11个字节, 也就是　RSA_size(rsa) – 11 如果输入的明文过长，必须切割，然后填充。<p>\n输出：和modulus一样长<p>\n根据这个要求，对于1024bit的密钥，block length = 1024/8 – 11 = 117 字节<p>\n\n* RSA_PKCS1_OAEP_PADDING<p>\n输入：RSA_size(rsa) – 41<p>\n输出：和modulus一样长<p>\n\n* RSA_NO_PADDING　　不填充<p>\n输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，　然后填充<p>\n输出：和modulus一样长<p>\n\n## 签名与验证\n\n```\n //对数据进行sha256签名\n- (NSData *)rsaSHA256SignData:(NSData *)plainData {\n      SecKeyRef key = [self getPrivatKey];\n    \n      size_t signedHashBytesSize = SecKeyGetBlockSize(key);\n      uint8_t* signedHashBytes = malloc(signedHashBytesSize);\n      memset(signedHashBytes, 0x0, signedHashBytesSize);\n    \n      size_t hashBytesSize = CC_SHA256_DIGEST_LENGTH;\n      uint8_t* hashBytes = malloc(hashBytesSize);\n      if (!CC_SHA256([plainData bytes], (CC_LONG)[plainData length], hashBytes)) {\n        return nil;\n    }\n    \n           SecKeyRawSign(key,\n                  kSecPaddingPKCS1SHA256,\n                  hashBytes,\n                  hashBytesSize,\n                  signedHashBytes,\n                  &signedHashBytesSize);\n    \n        NSData* signedHash = [NSData dataWithBytes:signedHashBytes\n                                        length:(NSUInteger)signedHashBytesSize];\n    \n        if (hashBytes)\n        free(hashBytes);\n    if (signedHashBytes)\n        free(signedHashBytes);\n    \n        return signedHash;\n}\n        \n```\n\n\n```\n\n//这边对签名的数据进行验证 验签成功，则返回YES\n- (BOOL)rsaSHA256VerifyData:(NSData *)plainData     withSignature:(NSData *)signature {\n        SecKeyRef key = [self getPublicKey];\n  \n        size_t signedHashBytesSize = SecKeyGetBlockSize(key);\n        const void* signedHashBytes = [signature bytes];\n    \n        size_t hashBytesSize = CC_SHA256_DIGEST_LENGTH;\n        uint8_t* hashBytes = malloc(hashBytesSize);\n        if (!CC_SHA256([plainData bytes], (CC_LONG)[plainData length], hashBytes)) {\n           return NO;\n        }\n    \n          OSStatus status = SecKeyRawVerify(key,\n                                      kSecPaddingPKCS1SHA256,\n                                      hashBytes,\n                                      hashBytesSize,\n                                      signedHashBytes,\n                                      signedHashBytesSize);\n    \n        return status == errSecSuccess;\n}\n```\n<p>\n**文章到此就结束了，希望大家能够喜欢。请点击[Git](https://github.com/PanXianyue/XYCryption)获取相关demo**","source":"_posts/RSA-SHA.md","raw":"---\ntitle: 一篇搞定RSA加密与SHA签名\ndate: 2016-01-12 17:19:25\ncategories: iOS\ntags: [RSA加密, SHA签名]\n---\n\n看到这篇文章的同学可幸福了，当时在做RSA加密与签名的时候网上的资料简直不要太老，做完后实在是忍受不下去了，这篇文章我会详细讲解iOS如何实现RSA加密与签名，并且与Java完全同步。\n<!--more-->\n\n# 基础知识 \n\n <p>\n\n1. **什么是RSA？**<p>\n答：RSA是一种非对称加密算法，常用来对传输数据进行加密，配合上数字摘要算法，也可以进行文字签名。\n\n2. **RSA加密中padding？**<p>\n答：padding即填充方式，由于RSA加密算法中要加密的明文是要比模数小的，padding就是通过一些填充方式来限制明文的长度。后面会详细介绍padding的几种模式以及分段加密。\n\n3. **加密和加签有什么区别？**<p>\n答：加密：公钥放在客户端，并使用公钥对数据进行加密，服务端拿到数据后用私钥进行解密； \n      加签：私钥放在客户端，并使用私钥对数据进行加签，服务端拿到数据后用公钥进行验签。       \n前者完全为了加密；后者主要是为了防恶意攻击，防止别人模拟我们的客户端对我们的服务器进行攻击，导致服务器瘫痪。\n\n# 基本原理<p>\n\nRSA使用“密钥对”对数据进行加密解密，在加密解密前需要先生存公钥（Public Key）和私钥（Private Key）。<p>\n**公钥(Public key):** 用于加密数据. 用于公开, 一般存放在数据提供方, 例如iOS客户端。<p>\n**私钥(Private key):** 用于解密数据. 必须保密, 私钥泄露会造成安全问题。<p>\niOS中的Security.framework提供了对RSA算法的支持，这种方式需要对密匙对进行处理, 根据public key生成证书, 通过private key生成p12格式的密匙。想想jave直接用字符串进行加密解密简单多了。(⊙o⊙)…\n\n# 实战\n<p>\n## 证书生成\nRSA加密这块公钥、私钥必不可少的。**Apple是不支持直接使用字符串进行加密解密的，推荐使用p12文件**。这边教大家去生成在加密中使用到的所有文件，并提供给Java使用，想当年这个公钥私钥搞了半天了。 %>_<%\n\n>* 生成模长为1024bit的私钥\nopenssl genrsa -out private_key.pem 1024\n* 生成certification require file\nopenssl req -new -key private_key.pem -out rsaCertReq.csr \n* 生成certification 并指定过期时间\nopenssl x509 -req -days3650-in rsaCertReq.csr -signkey private_key.pem -out rsaCert.crt\n* 生成公钥供iOS使用\nopenssl x509 -outform der -in rsaCert.crt -out public_key.der\n* 生成私钥供iOS使用 这边会让你输入密码，后期用到在生成secKeyRef的时候会用到这个密码\nopenssl pkcs12 -export -out private_key.p12 -inkey private_key.pem -in rsaCert.crt\n* 生成pem结尾的公钥供Java使用\nopenssl rsa -in private_key.pem -out rsa_public_key.pem -pubout\n* 生成pem结尾的私钥供Java使用openssl pkcs8 -topk8 -in private_key.pem -out pkcs8_private_key.pem -nocrypt\n\n**以上所有的步骤都是在终端下完成的哦  (*^__^*)**\n\n## 生成公钥和私钥的secKeyRef<p>\n   ```\n   //根据你的p12文件生成私钥对应的SecKeyRef 这边返回若是nil 请检查你p12文件的生成步骤\n- (SecKeyRef)getPrivateKeyRefrenceFromData:(NSData*)p12Data password:(NSString*)password {\n\nSecKeyRef privateKeyRef = NULL;\nNSMutableDictionary * options = [[NSMutableDictionary alloc] init];\n[options setObject: password forKey:(__bridge id)kSecImportExportPassphrase];\nCFArrayRef items = CFArrayCreate(NULL, 0, 0, NULL);\nOSStatus securityError = SecPKCS12Import((__bridge CFDataRef) p12Data, (__bridge CFDictionaryRef)options, &items);\nif (securityError == noErr && CFArrayGetCount(items) > 0) {\n    CFDictionaryRef identityDict = CFArrayGetValueAtIndex(items, 0);\n    SecIdentityRef identityApp = (SecIdentityRef)CFDictionaryGetValue(identityDict, kSecImportItemIdentity);\n    securityError = SecIdentityCopyPrivateKey(identityApp, &privateKeyRef);\n    if (securityError != noErr) {\n        privateKeyRef = NULL;\n    }\n}\nCFRelease(items);\n\nreturn privateKeyRef;\n}  \n   ```\n   \n   \n   ```\n    //根据你的der文件公钥对应的SecKeyRef\n - (SecKeyRef)getPublicKeyRefrenceFromeData:    (NSData*)derData {\n\nSecCertificateRef myCertificate = SecCertificateCreateWithData(kCFAllocatorDefault, (__bridge CFDataRef)derData);\nSecPolicyRef myPolicy = SecPolicyCreateBasicX509();\nSecTrustRef myTrust;\nOSStatus status = SecTrustCreateWithCertificates(myCertificate,myPolicy,&myTrust);\nSecTrustResultType trustResult;\nif (status == noErr) {\n    status = SecTrustEvaluate(myTrust, &trustResult);\n}\nSecKeyRef securityKey = SecTrustCopyPublicKey(myTrust);\nCFRelease(myCertificate);\nCFRelease(myPolicy);\nCFRelease(myTrust);\n\nreturn securityKey;\n}\n   ```\n   \n## 加密与解密 <p>\n \n ```\n - (NSData*)rsaEncryptData:(NSData*)data {\n    SecKeyRef key = [self getPublicKey];\n    size_t cipherBufferSize = SecKeyGetBlockSize(key);\n    uint8_t *cipherBuffer = malloc(cipherBufferSize * sizeof(uint8_t));\n    size_t blockSize = cipherBufferSize - 11;\n      size_t blockCount = (size_t)ceil([data length] / (double)blockSize);\n      NSMutableData *encryptedData = [[NSMutableData alloc] init];\n    for (int i=0; i<blockCount; i++) {\n    unsigned long bufferSize = MIN(blockSize , [data length] - i * blockSize);\n    NSData *buffer = [data subdataWithRange:NSMakeRange(i * blockSize, bufferSize)];\n    OSStatus status = SecKeyEncrypt(key, kSecPaddingPKCS1, (const uint8_t *)[buffer bytes], [buffer length], cipherBuffer, &cipherBufferSize);\n\n    if (status != noErr) {\n        return nil;\n    }\n\n    NSData *encryptedBytes = [[NSData alloc] initWithBytes:(const void *)cipherBuffer length:cipherBufferSize];\n    [encryptedData appendData:encryptedBytes];\n    }\n\n  if (cipherBuffer){\n    free(cipherBuffer);\n  }\n\n  return encryptedData;\n  }\n ```\n \n ```\n - (NSData*)rsaDecryptData:(NSData*)data {\nSecKeyRef key = [self getPrivatKey];\n\nsize_t cipherBufferSize = SecKeyGetBlockSize(key);\nsize_t blockSize = cipherBufferSize;\nsize_t blockCount = (size_t)ceil([data length] / (double)blockSize);\n\nNSMutableData *decryptedData = [[NSMutableData alloc] init];\n\nfor (int i = 0; i < blockCount; i++) {\n    unsigned long bufferSize = MIN(blockSize , [data length] - i * blockSize);\n    NSData *buffer = [data subdataWithRange:NSMakeRange(i * blockSize, bufferSize)];\n\n    size_t cipherLen = [buffer length];\n    void *cipher = malloc(cipherLen);\n    [buffer getBytes:cipher length:cipherLen];\n    size_t plainLen = SecKeyGetBlockSize(key);\n    void *plain = malloc(plainLen);\n\n    OSStatus status = SecKeyDecrypt(key, kSecPaddingPKCS1, cipher, cipherLen, plain, &plainLen);\n\n    if (status != noErr) {\n        return nil;\n    }\n\n    NSData *decryptedBytes = [[NSData alloc] initWithBytes:(const void *)plain length:plainLen];\n    [decryptedData appendData:decryptedBytes];\n}\n\nreturn decryptedData;\n}\n ```\n \n### RSA加密中的Padding \n\n* RSA_PKCS1_PADDING 填充模式，最常用的模式<p>\n要求: 输入：必须 比 RSA 钥模长(modulus) 短至少11个字节, 也就是　RSA_size(rsa) – 11 如果输入的明文过长，必须切割，然后填充。<p>\n输出：和modulus一样长<p>\n根据这个要求，对于1024bit的密钥，block length = 1024/8 – 11 = 117 字节<p>\n\n* RSA_PKCS1_OAEP_PADDING<p>\n输入：RSA_size(rsa) – 41<p>\n输出：和modulus一样长<p>\n\n* RSA_NO_PADDING　　不填充<p>\n输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，　然后填充<p>\n输出：和modulus一样长<p>\n\n## 签名与验证\n\n```\n //对数据进行sha256签名\n- (NSData *)rsaSHA256SignData:(NSData *)plainData {\n      SecKeyRef key = [self getPrivatKey];\n    \n      size_t signedHashBytesSize = SecKeyGetBlockSize(key);\n      uint8_t* signedHashBytes = malloc(signedHashBytesSize);\n      memset(signedHashBytes, 0x0, signedHashBytesSize);\n    \n      size_t hashBytesSize = CC_SHA256_DIGEST_LENGTH;\n      uint8_t* hashBytes = malloc(hashBytesSize);\n      if (!CC_SHA256([plainData bytes], (CC_LONG)[plainData length], hashBytes)) {\n        return nil;\n    }\n    \n           SecKeyRawSign(key,\n                  kSecPaddingPKCS1SHA256,\n                  hashBytes,\n                  hashBytesSize,\n                  signedHashBytes,\n                  &signedHashBytesSize);\n    \n        NSData* signedHash = [NSData dataWithBytes:signedHashBytes\n                                        length:(NSUInteger)signedHashBytesSize];\n    \n        if (hashBytes)\n        free(hashBytes);\n    if (signedHashBytes)\n        free(signedHashBytes);\n    \n        return signedHash;\n}\n        \n```\n\n\n```\n\n//这边对签名的数据进行验证 验签成功，则返回YES\n- (BOOL)rsaSHA256VerifyData:(NSData *)plainData     withSignature:(NSData *)signature {\n        SecKeyRef key = [self getPublicKey];\n  \n        size_t signedHashBytesSize = SecKeyGetBlockSize(key);\n        const void* signedHashBytes = [signature bytes];\n    \n        size_t hashBytesSize = CC_SHA256_DIGEST_LENGTH;\n        uint8_t* hashBytes = malloc(hashBytesSize);\n        if (!CC_SHA256([plainData bytes], (CC_LONG)[plainData length], hashBytes)) {\n           return NO;\n        }\n    \n          OSStatus status = SecKeyRawVerify(key,\n                                      kSecPaddingPKCS1SHA256,\n                                      hashBytes,\n                                      hashBytesSize,\n                                      signedHashBytes,\n                                      signedHashBytesSize);\n    \n        return status == errSecSuccess;\n}\n```\n<p>\n**文章到此就结束了，希望大家能够喜欢。请点击[Git](https://github.com/PanXianyue/XYCryption)获取相关demo**","slug":"RSA-SHA","published":1,"updated":"2016-08-25T03:51:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciup60i1d0000tlchp75c8r9c"},{"title":"执着","date":"2016-08-25T13:16:00.000Z","_content":"有些东西明明一文不值，却不舍得丢掉，<br>\n有时候找不着还会急得坐立不安。<br>\n问题是它们越来越旧，越来越老，而我已经渐渐不敢看它们。<br>\n它们装在盒子里，放在角落里，像一部部电影，<br>\n随时都能让我重新看到一场大雨，<br>\n一次分离，一杯咖啡，一个拥抱……<br>\n\n<!--more-->","source":"_posts/执着.md","raw":"---\ntitle: 执着\ndate: 2016-08-25 21:16:00\ntags:\n---\n有些东西明明一文不值，却不舍得丢掉，<br>\n有时候找不着还会急得坐立不安。<br>\n问题是它们越来越旧，越来越老，而我已经渐渐不敢看它们。<br>\n它们装在盒子里，放在角落里，像一部部电影，<br>\n随时都能让我重新看到一场大雨，<br>\n一次分离，一杯咖啡，一个拥抱……<br>\n\n<!--more-->","slug":"执着","published":1,"updated":"2016-08-25T13:18:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciup60i22000btlch1plcvfso"},{"title":"利用XCTool实现自动化打包","date":"2016-02-13T05:17:21.000Z","_content":"\n一个不会偷懒的程序员不是一个好程序员。每次编译打包都要花好长的时间，看了本篇博客后，就可以帮这些无聊的事情交给XCTool来做，我们喝喝茶，撩撩妹就行。\n<!--more-->\n\n\n# XCTool\n\nxctool是Facebook开源的一个命令行工具，用来代替苹果的xcodebuild工具。\n\n功能如下：\n\n* 像xcode一样能够编译程序\n* 编译的结果能够以结构化的形式输出\n* 编译内容输出彩色且方便阅读\n\n\n## 安装XCTool\n\n最简单的办法就是用homebrew安装xctool，这边就不介绍如何安装homebrew了。\n\n` brew install xctool`\n\n注：在用brew安装xctool的时候可能会出现can not install with HEAD error，当时尝试很多办法都没有搞定，像卸了重装... 终极解决方案：直接删除/usr/local里面里面所有的文件，*这边会导致你之前安装的一些插件会被删除，像CocoaPods*。\n\n## 编译\n\n`xctool -workspace ${project_path}/${project_name}.xcworkspace -scheme ${project_name} archive -archivePath ${project_path}/build/Debug-iphoneos/${project_name}_Debug.xcarchive -configuration ${build_Mode} || exit\n`\n \n# XcodeBuild\n\nshell里面会利用xcodebuild进行打包、清理工程\n\n## 打包\n`xcodebuild -exportArchive -archivePath ${project_path}/build/Debug-iphoneos/${project_name}_Debug.xcarchive -exportPath ${buildExportPath}/debug.ipa -exportFormat ipa \\\n-exportProvisioningProfile \"${profile_name}\" || exit`\n\n## 清理工程\n`xcodebuild clean -configuration ${build_Mode} || exit`\n\n\n# Linux命令\nshell里面会涉及到一些Linux命令：\n\n`echo \"输出内容\"`\n\n`echo '输出内容'`\n\n输出你想要输出的东西，*‘ ’表示要输出的内容为纯字符串，不可引用变量，“”表示输出的内容可包含变量*\n\n`cd ..`\n\n回退上一级目录\n\n`makdir`\n\n新建一个目录\n\n`rm -rf \"content\"`\n\n\n删除文件夹里面的所有内容\n\n**以上内容纯属虚构，若不感兴趣，完全可以跳过，直奔使用~**\n\n\n# 使用教程\n\n\n1. 将ipa_build这个文件夹移到和.xcodeproj或.xcworkspace同一级目录\n\n2. 打开build_debug或者build_release文件，替换profile_name字段，替换为你要打包项目的profile name\n\n3. 打开你的字段  `cd 脚本所在的目录` -> `chmod 777 build_debug.sh (仅第一次的时候需要)` -> `./build_debug.sh`\n\n4. 查看你的桌面即可以查看导出的IPA包\n\n<p>\n> 感谢大家花费时间来查看这篇blog，需要下载shell的同学请猛戳[Git](https://github.com/PanXianyue/ipa_build)。","source":"_posts/xctool-package.md","raw":"---\ntitle: 利用XCTool实现自动化打包\ndate: 2016-02-13 13:17:21\ncategories: iOS\ntags: [XCTOOL, SHELL, LINUX命令]\n---\n\n一个不会偷懒的程序员不是一个好程序员。每次编译打包都要花好长的时间，看了本篇博客后，就可以帮这些无聊的事情交给XCTool来做，我们喝喝茶，撩撩妹就行。\n<!--more-->\n\n\n# XCTool\n\nxctool是Facebook开源的一个命令行工具，用来代替苹果的xcodebuild工具。\n\n功能如下：\n\n* 像xcode一样能够编译程序\n* 编译的结果能够以结构化的形式输出\n* 编译内容输出彩色且方便阅读\n\n\n## 安装XCTool\n\n最简单的办法就是用homebrew安装xctool，这边就不介绍如何安装homebrew了。\n\n` brew install xctool`\n\n注：在用brew安装xctool的时候可能会出现can not install with HEAD error，当时尝试很多办法都没有搞定，像卸了重装... 终极解决方案：直接删除/usr/local里面里面所有的文件，*这边会导致你之前安装的一些插件会被删除，像CocoaPods*。\n\n## 编译\n\n`xctool -workspace ${project_path}/${project_name}.xcworkspace -scheme ${project_name} archive -archivePath ${project_path}/build/Debug-iphoneos/${project_name}_Debug.xcarchive -configuration ${build_Mode} || exit\n`\n \n# XcodeBuild\n\nshell里面会利用xcodebuild进行打包、清理工程\n\n## 打包\n`xcodebuild -exportArchive -archivePath ${project_path}/build/Debug-iphoneos/${project_name}_Debug.xcarchive -exportPath ${buildExportPath}/debug.ipa -exportFormat ipa \\\n-exportProvisioningProfile \"${profile_name}\" || exit`\n\n## 清理工程\n`xcodebuild clean -configuration ${build_Mode} || exit`\n\n\n# Linux命令\nshell里面会涉及到一些Linux命令：\n\n`echo \"输出内容\"`\n\n`echo '输出内容'`\n\n输出你想要输出的东西，*‘ ’表示要输出的内容为纯字符串，不可引用变量，“”表示输出的内容可包含变量*\n\n`cd ..`\n\n回退上一级目录\n\n`makdir`\n\n新建一个目录\n\n`rm -rf \"content\"`\n\n\n删除文件夹里面的所有内容\n\n**以上内容纯属虚构，若不感兴趣，完全可以跳过，直奔使用~**\n\n\n# 使用教程\n\n\n1. 将ipa_build这个文件夹移到和.xcodeproj或.xcworkspace同一级目录\n\n2. 打开build_debug或者build_release文件，替换profile_name字段，替换为你要打包项目的profile name\n\n3. 打开你的字段  `cd 脚本所在的目录` -> `chmod 777 build_debug.sh (仅第一次的时候需要)` -> `./build_debug.sh`\n\n4. 查看你的桌面即可以查看导出的IPA包\n\n<p>\n> 感谢大家花费时间来查看这篇blog，需要下载shell的同学请猛戳[Git](https://github.com/PanXianyue/ipa_build)。","slug":"xctool-package","published":1,"updated":"2016-08-25T07:25:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciup60i25000ctlchg7an26to"},{"title":"Sketch--makeicons","date":"2016-09-26T09:05:53.000Z","_content":"\n一枚不务正业的iOS工程师\n<!--more-->\n\n## makeiconswithsketch\n\n![](http://7xq5ax.com1.z0.glb.clouddn.com/sketch-symbol)\n\n\n<p>\n## 相关链接\n* **Sketch Toolbox**:http://sketchtoolbox.com/\n* **creativemarket**:https://creativemarket.com/\n* **Sketch中文手册**:http://www.sketchcn.com/sketch-chinese-user-manual.html\n* **dribbble**:https://dribbble.com/shots\n\n> 模仿[Allen朝辉](http://weibo.com/wangchaohui?from=myfollow_all&is_all=1#1474879197597)实现了一遍，So good！初学设计，有什么不足之处还望指导。\n> 资源放在[git](https://github.com/PanXianyue/BlogDemo/tree/master/Sketch)上，方便管理。","source":"_posts/sketch-makeicons.md","raw":"---\ntitle: Sketch--makeicons\ndate: 2016-09-26 17:05:53\ntags:\n---\n\n一枚不务正业的iOS工程师\n<!--more-->\n\n## makeiconswithsketch\n\n![](http://7xq5ax.com1.z0.glb.clouddn.com/sketch-symbol)\n\n\n<p>\n## 相关链接\n* **Sketch Toolbox**:http://sketchtoolbox.com/\n* **creativemarket**:https://creativemarket.com/\n* **Sketch中文手册**:http://www.sketchcn.com/sketch-chinese-user-manual.html\n* **dribbble**:https://dribbble.com/shots\n\n> 模仿[Allen朝辉](http://weibo.com/wangchaohui?from=myfollow_all&is_all=1#1474879197597)实现了一遍，So good！初学设计，有什么不足之处还望指导。\n> 资源放在[git](https://github.com/PanXianyue/BlogDemo/tree/master/Sketch)上，方便管理。","slug":"sketch-makeicons","published":1,"updated":"2016-10-25T07:16:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciup60i29000ktlchkq2gjvb6"},{"title":"YYKit源码分析---pthread","date":"2016-06-21T09:43:18.000Z","_content":"\n大家都知道ibireme的[YYKit](https://github.com/ibireme/YYKit)很强大，个人也特别佩服ibireme。大神常常教导我们这样的小白说：多读源码能够大幅度的提高功力。 <p>每当项目上线后，需求还没有下来时，都会有一段闲暇时间。这段时间学习是极佳的。YYKit这个框架刚开始看的时候就遇到pthread这个玩意，之前很少接触。在此，记录自己的所学所得，并分享给大家。\n<!--more-->\n\n\n## 先来看下YY定义的宏\n```\nstatic inline void pthread_mutex_init_recursive(pthread_mutex_t *mutex, bool recursive) {\n#define YYMUTEX_ASSERT_ON_ERROR(x_) do { \\\n__unused volatile int res = (x_); \\\nassert(res == 0); \\\n} while (0)\n    assert(mutex != NULL);\n    if (!recursive) {\n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutex_init(mutex, NULL));\n    } else {\n        pthread_mutexattr_t attr;\n        \n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutexattr_init (&attr));\n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE));\n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutex_init (mutex, &attr));\n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutexattr_destroy (&attr));\n    }\n#undef YYMUTEX_ASSERT_ON_ERROR\n}   \n```\n大神的代码都是晦涩难懂的，看到这段代码后劳资突然产生了好几个问题：\n\n- 这个方法是用来干嘛的呢？\n- pthread_mutex_t是什么鬼？\n- pthread_mutexattr_t是用来配置pthread_mutex_t的吗？\n\n## 解读\n#### 功能\n其实就是创建个互斥线程，并没有想象中的可怕\n#### pthread_mutex_t\n`int pthread_mutex_init(pthread_mutex_t * __restrict,\n\t\tconst pthread_mutexattr_t * __restrict);` 是用这个函数创建出来的。函数是以动态的方式创建互斥锁的，参数attr指定了新建互斥锁的属性。<br>`recursive`这个`bool`值为false时，attr为空，则使用默认的互斥锁属性，默认属性为快速互斥锁。<br>`recursive`这个`bool`值为true时，配置互斥锁属性创建相应的互斥锁。\n#### YYMUTEX_ASSERT_ON_ERROR\n断言来进行检查错误，所有操作返回非0时，表示有异常错误发生\n#### Mutex type attributes\n**PTHREAD_MUTEX_NORMAL**：不进行deadlock detection（死锁检测）。当进行relock时，这个mutex就导致deadlock。对一个没有进行lock或者已经unlock的对象进行unlock操作，结果也是未知的。<br>**PTHREAD_MUTEX_ERRORCHECK**：和PTHREAD_MUTEX_NORMAL相比，PTHREAD_MUTEX_ERRORCHECK会进行错误检测，以上错误行为都会返回一个错误。<br>**PTHREAD_MUTEX_RECURSIVE**：和semaphore（信号量）有个类似的东西，mutex会有个锁住次数的概念，第一次锁住mutex的时候，锁住次数设置为1，每一次一个线程unlock这个mutex时，锁住次数就会减1。当锁住次数为0时，其他线程就可以获得该mutex锁了。同样，对一个没有进行lock或者已经unlock的对象进行unlock操作，将返回一个错误。<br>**PTHREAD_MUTEX_DEFAULT**：默认PTHREAD_MUTEX_NORMAL。\n\n## 再看看YY如何使用该宏\n```\n- (YYImageFrame *)frameAtIndex:(NSUInteger)index decodeForDisplay:(BOOL)decodeForDisplay {\n    YYImageFrame *result = nil;\n    pthread_mutex_lock(&_lock);\n    result = [self _frameAtIndex:index decodeForDisplay:decodeForDisplay];\n    pthread_mutex_unlock(&_lock);\n    return result;\n}\n```\n**这边为了防止多线程资源抢夺的问题，先进行lock下，等数据操作完毕后释放unlock，有没有一种豁然开朗的感觉呢<br>平时我们在多线程操作的时候也可以使用NSLock、synchronized来进行加锁，yy使用了更加偏向底层的pthread**\n\n## pthread_t和NSThread\n两者都是用来操作线程的对象，平时我们使用上层的NSThread比较多，像[NSThread mainThread]获取主线程，[NSThread currentThread] 获取当前线程。pthread_t和NSThread是一一对应的，同样可以通过pthread_main_thread_np() 、pthread_self()来获取。NSThread只是对pthread_t的一层封装而已。\n\n## 实战\n- 声明函数\n\n```\nvoid *func(void *argu) {\n    char *m = (char *)argu;\n\n    pthread_mutex_lock(&mutex);\n    while (*m != '\\0') {\n        printf(\"%c\", *m);\n        fflush(stdout);\n        sleep(3);\n        m++;\n    }\n    printf(\"\\n\");\n    pthread_mutex_unlock(&mutex);\n    return 0;\n}\n```\n\n- mutex使用 \n\n```\n    int rc1, rc2;\n    \n    char *str1 = \"Hi\";\n    char *str2 = \"Boy!\";\n    \n    pthread_t thread1, thread2;\n    pthread_mutex_init(&mutex, NULL);\n\n    if ((rc1 = pthread_create(&thread1, NULL, func, str1))) {\n        fprintf(stdout, \"thread1 creat fail : %d \\n!\", rc1);\n    }\n    if ((rc2 = pthread_create(&thread2, NULL, func, str2))) {\n        fprintf(stdout, \"thread2 creat fail : %d \\n!\", rc2);\n    }\n\n    // https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man3/pthread_join.3.html#//apple_ref/c/func/pthread_join\n    // 等待一个线程的结束，当函数返回时，被等待的线程资源被收回。若线程已经被收回，那么该函数会立即返回\n    pthread_join(thread1, NULL);\n    pthread_join(thread2, NULL);\n\n\tprintf(\"这边只有线程被回收后才会执行！\");\n```\n- 可以帮pthread_mutex_lock(&mutex)和pthread_mutex_unlock(&mutex)注释掉看下打印<p>\n\n> 感谢大家花费时间来查看这篇blog，需要下载demo的同学请猛戳[Git](https://github.com/PanXianyue/BlogDemo)。","source":"_posts/YYKit-pthread.md","raw":"---\ntitle: YYKit源码分析---pthread\ndate: 2016-06-21 17:43:18\ncategories: iOS\ntags: [YYKit, pthread]\n---\n\n大家都知道ibireme的[YYKit](https://github.com/ibireme/YYKit)很强大，个人也特别佩服ibireme。大神常常教导我们这样的小白说：多读源码能够大幅度的提高功力。 <p>每当项目上线后，需求还没有下来时，都会有一段闲暇时间。这段时间学习是极佳的。YYKit这个框架刚开始看的时候就遇到pthread这个玩意，之前很少接触。在此，记录自己的所学所得，并分享给大家。\n<!--more-->\n\n\n## 先来看下YY定义的宏\n```\nstatic inline void pthread_mutex_init_recursive(pthread_mutex_t *mutex, bool recursive) {\n#define YYMUTEX_ASSERT_ON_ERROR(x_) do { \\\n__unused volatile int res = (x_); \\\nassert(res == 0); \\\n} while (0)\n    assert(mutex != NULL);\n    if (!recursive) {\n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutex_init(mutex, NULL));\n    } else {\n        pthread_mutexattr_t attr;\n        \n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutexattr_init (&attr));\n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE));\n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutex_init (mutex, &attr));\n        YYMUTEX_ASSERT_ON_ERROR(pthread_mutexattr_destroy (&attr));\n    }\n#undef YYMUTEX_ASSERT_ON_ERROR\n}   \n```\n大神的代码都是晦涩难懂的，看到这段代码后劳资突然产生了好几个问题：\n\n- 这个方法是用来干嘛的呢？\n- pthread_mutex_t是什么鬼？\n- pthread_mutexattr_t是用来配置pthread_mutex_t的吗？\n\n## 解读\n#### 功能\n其实就是创建个互斥线程，并没有想象中的可怕\n#### pthread_mutex_t\n`int pthread_mutex_init(pthread_mutex_t * __restrict,\n\t\tconst pthread_mutexattr_t * __restrict);` 是用这个函数创建出来的。函数是以动态的方式创建互斥锁的，参数attr指定了新建互斥锁的属性。<br>`recursive`这个`bool`值为false时，attr为空，则使用默认的互斥锁属性，默认属性为快速互斥锁。<br>`recursive`这个`bool`值为true时，配置互斥锁属性创建相应的互斥锁。\n#### YYMUTEX_ASSERT_ON_ERROR\n断言来进行检查错误，所有操作返回非0时，表示有异常错误发生\n#### Mutex type attributes\n**PTHREAD_MUTEX_NORMAL**：不进行deadlock detection（死锁检测）。当进行relock时，这个mutex就导致deadlock。对一个没有进行lock或者已经unlock的对象进行unlock操作，结果也是未知的。<br>**PTHREAD_MUTEX_ERRORCHECK**：和PTHREAD_MUTEX_NORMAL相比，PTHREAD_MUTEX_ERRORCHECK会进行错误检测，以上错误行为都会返回一个错误。<br>**PTHREAD_MUTEX_RECURSIVE**：和semaphore（信号量）有个类似的东西，mutex会有个锁住次数的概念，第一次锁住mutex的时候，锁住次数设置为1，每一次一个线程unlock这个mutex时，锁住次数就会减1。当锁住次数为0时，其他线程就可以获得该mutex锁了。同样，对一个没有进行lock或者已经unlock的对象进行unlock操作，将返回一个错误。<br>**PTHREAD_MUTEX_DEFAULT**：默认PTHREAD_MUTEX_NORMAL。\n\n## 再看看YY如何使用该宏\n```\n- (YYImageFrame *)frameAtIndex:(NSUInteger)index decodeForDisplay:(BOOL)decodeForDisplay {\n    YYImageFrame *result = nil;\n    pthread_mutex_lock(&_lock);\n    result = [self _frameAtIndex:index decodeForDisplay:decodeForDisplay];\n    pthread_mutex_unlock(&_lock);\n    return result;\n}\n```\n**这边为了防止多线程资源抢夺的问题，先进行lock下，等数据操作完毕后释放unlock，有没有一种豁然开朗的感觉呢<br>平时我们在多线程操作的时候也可以使用NSLock、synchronized来进行加锁，yy使用了更加偏向底层的pthread**\n\n## pthread_t和NSThread\n两者都是用来操作线程的对象，平时我们使用上层的NSThread比较多，像[NSThread mainThread]获取主线程，[NSThread currentThread] 获取当前线程。pthread_t和NSThread是一一对应的，同样可以通过pthread_main_thread_np() 、pthread_self()来获取。NSThread只是对pthread_t的一层封装而已。\n\n## 实战\n- 声明函数\n\n```\nvoid *func(void *argu) {\n    char *m = (char *)argu;\n\n    pthread_mutex_lock(&mutex);\n    while (*m != '\\0') {\n        printf(\"%c\", *m);\n        fflush(stdout);\n        sleep(3);\n        m++;\n    }\n    printf(\"\\n\");\n    pthread_mutex_unlock(&mutex);\n    return 0;\n}\n```\n\n- mutex使用 \n\n```\n    int rc1, rc2;\n    \n    char *str1 = \"Hi\";\n    char *str2 = \"Boy!\";\n    \n    pthread_t thread1, thread2;\n    pthread_mutex_init(&mutex, NULL);\n\n    if ((rc1 = pthread_create(&thread1, NULL, func, str1))) {\n        fprintf(stdout, \"thread1 creat fail : %d \\n!\", rc1);\n    }\n    if ((rc2 = pthread_create(&thread2, NULL, func, str2))) {\n        fprintf(stdout, \"thread2 creat fail : %d \\n!\", rc2);\n    }\n\n    // https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man3/pthread_join.3.html#//apple_ref/c/func/pthread_join\n    // 等待一个线程的结束，当函数返回时，被等待的线程资源被收回。若线程已经被收回，那么该函数会立即返回\n    pthread_join(thread1, NULL);\n    pthread_join(thread2, NULL);\n\n\tprintf(\"这边只有线程被回收后才会执行！\");\n```\n- 可以帮pthread_mutex_lock(&mutex)和pthread_mutex_unlock(&mutex)注释掉看下打印<p>\n\n> 感谢大家花费时间来查看这篇blog，需要下载demo的同学请猛戳[Git](https://github.com/PanXianyue/BlogDemo)。","slug":"YYKit-pthread","published":1,"updated":"2016-08-25T03:48:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciup60i2c000ltlchdlwvll6y"},{"title":"YYKit源码分析---YYCache","date":"2016-07-18T14:47:35.000Z","_content":"[YYCache](https://github.com/ibireme/YYCache)是用于Objective-C中用于缓存的第三方框架。此文主要用来讲解该框架的实现细节，性能分析、设计思路ibireme已经讲得很清楚了，我这边就不在分析了。\n\n<!--more-->\n\n## 文件结构\n![](http://7xq5ax.com1.z0.glb.clouddn.com/yycache-tree.png)\n1. YYCache：同时实现内存缓存和磁盘缓存且是线程安全的\n2. YYMemoryCache：实现内存缓存，所有的API都是线程安全的，与其他缓存方式比较不同的是内部利用LRU淘汰算法（后面会介绍）来提高性能\n3. YYDiskCache：实现磁盘缓存，所有的API都是线程安全的，内部也采用了LRU淘汰算法，主要SQLite和文件存储两种方式\n4. YYKVStorage：实现磁盘存储，不推荐直接使用该类，该类不是线程安全的\n\n## LRU\nLRU(Least recently used，最近最少使用)算法，根据访问的历史记录来对数据进行淘汰\n<p>\n![](http://7xq5ax.com1.z0.glb.clouddn.com/lru.png)\n<p>\n简单的来说3点：\n\n1. 有新数据加入时添加到链表的头部\n2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部\n3. 当链表满的时候，将链表尾部的数据丢弃\n\n**在YYMemoryCache中使用来双向链表和NSDictionary实现了LRU淘汰算法，后面会介绍**\n\n## 关于锁\nYYCache 使用到两种锁\n\n1. OSSpinLock ：自旋锁，上一篇博客也提及到[pthread_mutex](http://iipanda.com/2016/06/21/YYKit-pthread/) \n2. dispatch_semaphore：信号量，当信号量为1的时候充当锁来用\n\n**内存缓存用的pthread_mutex：由于pthread_mutex相当于do while忙等，等待时会消耗大量的CPU资源<br>磁盘缓存使用的dispatch_semaphore：优势在于等待时不会消耗CPU资源**\n> 简单的科普就到这，现在来开始源码的探索\n\n## _YYLinkedMap\n```\n@interface _YYLinkedMapNode : NSObject {\n    @package\n    __unsafe_unretained _YYLinkedMapNode *_prev; // retained by dic\n    __unsafe_unretained _YYLinkedMapNode *_next; // retained by dic\n    id _key;\n    id _value;\n    NSUInteger _cost;\n    NSTimeInterval _time;\n}\n@end\n```\n**_YYLinkedMapNode**：链表的节点<br>\n\\_prev、\\_next：分别表示指向上一个节点、下一个节点<br>\n\\_key：缓存的key<br>\n\\_value：缓存对象<br>\n\\_cost：内存消耗<br>\n\\_time：缓存时间<br>\n\n```\n@interface _YYLinkedMap : NSObject {\n    @package\n    CFMutableDictionaryRef _dic; // do not set object directly\n    NSUInteger _totalCost;\n    NSUInteger _totalCount;\n    _YYLinkedMapNode *_head; // MRU（最近最常使用算法）, do not change it directly\n    _YYLinkedMapNode *_tail; // LRU（最近最少使用算法-清除较不常使用数据）, do not change it directly\n    BOOL _releaseOnMainThread;\n    BOOL _releaseAsynchronously;\n}\n\n```\n**_YYLinkedMap**：链表<br>\n\\_dic：用来保存节点<br>\n\\_totalCost：总缓存开销<br>\n\\_head、\\_tail：头节点、尾节点<br>\n\\_releaseOnMainThread：是否在主线程释放\\_YYLinkedMapNode<br>\n\\_releaseAsynchronously：是否异步释放\\_YYLinkedMapNode<br>\n\n\n**双向链表**<br>\n![](http://7xq5ax.com1.z0.glb.clouddn.com/LinkedMap@1x.png)\n\n1. 插入节点到头部\n2. 将除两边的节点移到头部\n3. 移除除两边的节点\n4. 移除尾部节点\n5. 移除所有节点\n\n看下移除所有节点的代码：\n\n```\n- (void)removeAll {\n    _totalCost = 0;\n    _totalCount = 0;\n    _head = nil;\n    _tail = nil;\n    if (CFDictionaryGetCount(_dic) > 0) {\n        CFMutableDictionaryRef holder = _dic;\n        _dic = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n        \n        if (_releaseAsynchronously) {\n            dispatch_queue_t queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();\n            dispatch_async(queue, ^{\n                CFRelease(holder); // hold and release in specified queue\n            });\n        } else if (_releaseOnMainThread && !pthread_main_np()) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                CFRelease(holder); // hold and release in specified queue\n            });\n        } else {\n            CFRelease(holder);\n        }\n    }\n}\n\n\n```\n\n\n\n这边通过双向链表来对数据进行操作，和NSDictionary实现了LRU淘汰算法。时间复杂度0（1），5种操作基本上都是对头尾节点和链表节点的上一个节点和下一个节点进行操作。\n\n\n## YYMemoryCache\n这边介绍两个主要的操作：添加缓存，查找缓存<p>\n\n- **添加缓存**\n\n```\n- (void)setObject:(id)object forKey:(id)key withCost:(NSUInteger)cost {\n    if (!key) return;\n    if (!object) {\n        // 缓存对象为nil，直接移除\n        [self removeObjectForKey:key];\n        return;\n    }\n    // 为了保证线程安全，数据操作前进行加锁\n    pthread_mutex_lock(&_lock);\n    // 查找缓存\n    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru->_dic, (__bridge const void *)(key));\n    // 当前时间\n    NSTimeInterval now = CACurrentMediaTime();\n    if (node) {\n        // 缓存对象已存在，更新数据，并移到栈顶\n        _lru->_totalCost -= node->_cost;\n        _lru->_totalCost += cost;\n        node->_cost = cost;\n        node->_time = now;\n        node->_value = object;\n        [_lru bringNodeToHead:node];\n    } else {\n        // 缓存对象不存在，添加数据，并移到栈顶\n        node = [_YYLinkedMapNode new];\n        node->_cost = cost;\n        node->_time = now;\n        node->_key = key;\n        node->_value = object;\n        [_lru insertNodeAtHead:node];\n    }\n    // 判断当前的缓存进行是否超出了设定值，若超出则进行整理\n    if (_lru->_totalCost > _costLimit) {\n        dispatch_async(_queue, ^{\n            [self trimToCost:_costLimit];\n        });\n    }\n    \n    // 每次添加数据仅有一个，数量上超出时，直接移除尾部那个object即可\n    if (_lru->_totalCount > _countLimit) {\n        _YYLinkedMapNode *node = [_lru removeTailNode];\n        if (_lru->_releaseAsynchronously) {\n            dispatch_queue_t queue = _lru->_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();\n            dispatch_async(queue, ^{\n                [node class]; //hold and release in queue\n            });\n        } else if (_lru->_releaseOnMainThread && !pthread_main_np()) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [node class]; //hold and release in queue\n            });\n        }\n    }\n    // 操作结束，解锁\n    pthread_mutex_unlock(&_lock);\n}\n\n```\n\n- **异步线程释放**\n![](http://7xq5ax.com1.z0.glb.clouddn.com/%E5%BC%82%E6%AD%A5%E9%87%8A%E6%94%BE.png)\n里面很多都用到类似的方法，将一个对象在异步线程中释放，来分析下：<br>\n\n\n\t\t- p\n\t\t1. 首先通过node来对其进行持有，以至于不会在方法调用结束的时候被销毁\n\t\t2. 我要要在其他线程中进行销毁，所以将销毁操作放在block中，block就会对其进行持有\n\t\t3. 这边在block中随便调用了个方法，保证编译器不会优化掉这个操作\n\t\t4. 当block结束后，node没有被持有的时候，就会在当前线程被release掉了\n\n\n\n- **添加缓存**\n\n```\n// 这边从memory中取数据时，根据LRU原则，将最新取出的object放到栈头\n- (id)objectForKey:(id)key {\n    if (!key) return nil;\n    pthread_mutex_lock(&_lock);\n    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru->_dic, (__bridge const void *)(key));\n    if (node) {\n        node->_time = CACurrentMediaTime();\n        [_lru bringNodeToHead:node];\n    }\n    pthread_mutex_unlock(&_lock);\n    return node ? node->_value : nil;\n}\n\n```\n\n## YYKVStorage\n\n该文件主要以两种方式来实现磁盘存储：SQLite、File，使用两种方式混合进行存储主要为了提高读写效率。写入数据时，SQLite要比文件的方式更快；读取数据的速度主要取决于文件的大小。据测试，在iPhone6中，当文件大小超过20kb时，File要比SQLite快的多。所以当大文件存储时建议用File的方式，小文件更适合用SQLite。<p>\n下边分别对Save、Remove、Get分别进行分析\n\n\n- **Save**\n\n```\n- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(NSString *)filename extendedData:(NSData *)extendedData {\n    // 条件不符合\n    if (key.length == 0 || value.length == 0) return NO;\n    if (_type == YYKVStorageTypeFile && filename.length == 0) {\n        return NO;\n    }\n    \n    if (filename.length) {    // filename存在 SQLite File两种方式并行\n        // 用文件进行存储\n        if (![self _fileWriteWithName:filename data:value]) {\n            return NO;\n        }\n        // 用SQLite进行存储\n        if (![self _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) {\n            // 当使用SQLite方式存储失败时，删除本地文件存储\n            [self _fileDeleteWithName:filename];\n            return NO;\n        }\n        return YES;\n    } else {               // filename不存在 SQLite\n        if (_type != YYKVStorageTypeSQLite) {\n            // 这边去到filename后，删除filename对应的file文件\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            if (filename) {\n                [self _fileDeleteWithName:filename];\n            }\n        }\n        // SQLite 进行存储\n        return [self _dbSaveWithKey:key value:value fileName:nil extendedData:extendedData];\n    }\n}\n\n\n```\n\n- **Remove**\n\n```\n- (BOOL)removeItemForKey:(NSString *)key {\n    if (key.length == 0) return NO;\n    switch (_type) {\n        case YYKVStorageTypeSQLite: {\n            // 删除SQLite文件\n            return [self _dbDeleteItemWithKey:key];\n        } break;\n        case YYKVStorageTypeFile:\n        case YYKVStorageTypeMixed: {\n            // 获取filename\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            if (filename) {\n                // 删除filename对的file\n                [self _fileDeleteWithName:filename];\n            }\n            // 删除SQLite文件\n            return [self _dbDeleteItemWithKey:key];\n        } break;\n        default: return NO;\n    }\n}\n\n```\n\n- **Get**\n\n```\n- (NSData *)getItemValueForKey:(NSString *)key {\n    if (key.length == 0) return nil;\n    NSData *value = nil;\n    switch (_type) {\n        case YYKVStorageTypeFile: { //File\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            if (filename) {\n                // 根据filename获取File\n                value = [self _fileReadWithName:filename];\n                if (!value) {\n                    // 当value不存在，用对应的key删除SQLite文件\n                    [self _dbDeleteItemWithKey:key];\n                    value = nil;\n                }\n            }\n        } break;\n        case YYKVStorageTypeSQLite: {\n            // SQLite 方式获取\n            value = [self _dbGetValueWithKey:key];\n        } break;\n        case YYKVStorageTypeMixed: {\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            // filename 存在文件获取，不存在SQLite方式获取\n            if (filename) {\n                value = [self _fileReadWithName:filename];\n                if (!value) {\n                    [self _dbDeleteItemWithKey:key];\n                    value = nil;\n                }\n            } else {\n                value = [self _dbGetValueWithKey:key];\n            }\n        } break;\n    }\n    if (value) {\n        // 更新文件操作时间\n        [self _dbUpdateAccessTimeWithKey:key];\n    }\n    return value;\n}\n\n```\n\nFile方式主要使用的writeToFile进行存储，SQLte直接使用的sqlite3来对文件进行操作，具体数据库相关的操作这边就不在进行分析了，感兴趣的自己可以阅读下\n\n## YYDiskCache\n\nYYDiskCache是对YYKVStorage进行的一次封装，是线程安全的，这边使用的是dispatch_semaphore_signal来确保线程的安全。另外他结合LRU算法，根据文件的大小自动选择存储方式来达到更好的性能。\n\n```\n- (instancetype)initWithPath:(NSString *)path\n             inlineThreshold:(NSUInteger)threshold {\n    self = [super init];\n    if (!self) return nil;\n    \n    // 获取缓存的 YYDiskCache\n    YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);\n    if (globalCache) return globalCache;\n    \n    // 确定存储的方式\n    YYKVStorageType type;\n    if (threshold == 0) {\n        type = YYKVStorageTypeFile;\n    } else if (threshold == NSUIntegerMax) {\n        type = YYKVStorageTypeSQLite;\n    } else {\n        type = YYKVStorageTypeMixed;\n    }\n    \n    // 初始化 YYKVStorage\n    YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type];\n    if (!kv) return nil;\n    \n    // 初始化数据\n    _kv = kv;\n    _path = path;\n    _lock = dispatch_semaphore_create(1);\n    _queue = dispatch_queue_create(\"com.ibireme.cache.disk\", DISPATCH_QUEUE_CONCURRENT);\n    _inlineThreshold = threshold;\n    _countLimit = NSUIntegerMax;\n    _costLimit = NSUIntegerMax;\n    _ageLimit = DBL_MAX;\n    _freeDiskSpaceLimit = 0;\n    _autoTrimInterval = 60;\n    \n    // 递归的去整理文件\n    [self _trimRecursively];\n    // 对当前对象进行缓存\n    _YYDiskCacheSetGlobal(self);\n    \n    // 通知 APP即将被杀死时\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_appWillBeTerminated) name:UIApplicationWillTerminateNotification object:nil];\n    return self;\n}\n\n```\n\n其他的一些操作基本上都是对YYKVStorage的一些封装，这边就不一一分析了。\n\n## 参考文献\n\n1. http://blog.ibireme.com/2015/10/26/yycache/\n2. http://blog.csdn.net/yunhua_lee/article/details/7599671\n","source":"_posts/YYCache-analyzing.md","raw":"---\ntitle: YYKit源码分析---YYCache\ndate: 2016-07-18 22:47:35\ncategories: iOS\ntags: [YYKit, YYCache]\n---\n[YYCache](https://github.com/ibireme/YYCache)是用于Objective-C中用于缓存的第三方框架。此文主要用来讲解该框架的实现细节，性能分析、设计思路ibireme已经讲得很清楚了，我这边就不在分析了。\n\n<!--more-->\n\n## 文件结构\n![](http://7xq5ax.com1.z0.glb.clouddn.com/yycache-tree.png)\n1. YYCache：同时实现内存缓存和磁盘缓存且是线程安全的\n2. YYMemoryCache：实现内存缓存，所有的API都是线程安全的，与其他缓存方式比较不同的是内部利用LRU淘汰算法（后面会介绍）来提高性能\n3. YYDiskCache：实现磁盘缓存，所有的API都是线程安全的，内部也采用了LRU淘汰算法，主要SQLite和文件存储两种方式\n4. YYKVStorage：实现磁盘存储，不推荐直接使用该类，该类不是线程安全的\n\n## LRU\nLRU(Least recently used，最近最少使用)算法，根据访问的历史记录来对数据进行淘汰\n<p>\n![](http://7xq5ax.com1.z0.glb.clouddn.com/lru.png)\n<p>\n简单的来说3点：\n\n1. 有新数据加入时添加到链表的头部\n2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部\n3. 当链表满的时候，将链表尾部的数据丢弃\n\n**在YYMemoryCache中使用来双向链表和NSDictionary实现了LRU淘汰算法，后面会介绍**\n\n## 关于锁\nYYCache 使用到两种锁\n\n1. OSSpinLock ：自旋锁，上一篇博客也提及到[pthread_mutex](http://iipanda.com/2016/06/21/YYKit-pthread/) \n2. dispatch_semaphore：信号量，当信号量为1的时候充当锁来用\n\n**内存缓存用的pthread_mutex：由于pthread_mutex相当于do while忙等，等待时会消耗大量的CPU资源<br>磁盘缓存使用的dispatch_semaphore：优势在于等待时不会消耗CPU资源**\n> 简单的科普就到这，现在来开始源码的探索\n\n## _YYLinkedMap\n```\n@interface _YYLinkedMapNode : NSObject {\n    @package\n    __unsafe_unretained _YYLinkedMapNode *_prev; // retained by dic\n    __unsafe_unretained _YYLinkedMapNode *_next; // retained by dic\n    id _key;\n    id _value;\n    NSUInteger _cost;\n    NSTimeInterval _time;\n}\n@end\n```\n**_YYLinkedMapNode**：链表的节点<br>\n\\_prev、\\_next：分别表示指向上一个节点、下一个节点<br>\n\\_key：缓存的key<br>\n\\_value：缓存对象<br>\n\\_cost：内存消耗<br>\n\\_time：缓存时间<br>\n\n```\n@interface _YYLinkedMap : NSObject {\n    @package\n    CFMutableDictionaryRef _dic; // do not set object directly\n    NSUInteger _totalCost;\n    NSUInteger _totalCount;\n    _YYLinkedMapNode *_head; // MRU（最近最常使用算法）, do not change it directly\n    _YYLinkedMapNode *_tail; // LRU（最近最少使用算法-清除较不常使用数据）, do not change it directly\n    BOOL _releaseOnMainThread;\n    BOOL _releaseAsynchronously;\n}\n\n```\n**_YYLinkedMap**：链表<br>\n\\_dic：用来保存节点<br>\n\\_totalCost：总缓存开销<br>\n\\_head、\\_tail：头节点、尾节点<br>\n\\_releaseOnMainThread：是否在主线程释放\\_YYLinkedMapNode<br>\n\\_releaseAsynchronously：是否异步释放\\_YYLinkedMapNode<br>\n\n\n**双向链表**<br>\n![](http://7xq5ax.com1.z0.glb.clouddn.com/LinkedMap@1x.png)\n\n1. 插入节点到头部\n2. 将除两边的节点移到头部\n3. 移除除两边的节点\n4. 移除尾部节点\n5. 移除所有节点\n\n看下移除所有节点的代码：\n\n```\n- (void)removeAll {\n    _totalCost = 0;\n    _totalCount = 0;\n    _head = nil;\n    _tail = nil;\n    if (CFDictionaryGetCount(_dic) > 0) {\n        CFMutableDictionaryRef holder = _dic;\n        _dic = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n        \n        if (_releaseAsynchronously) {\n            dispatch_queue_t queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();\n            dispatch_async(queue, ^{\n                CFRelease(holder); // hold and release in specified queue\n            });\n        } else if (_releaseOnMainThread && !pthread_main_np()) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                CFRelease(holder); // hold and release in specified queue\n            });\n        } else {\n            CFRelease(holder);\n        }\n    }\n}\n\n\n```\n\n\n\n这边通过双向链表来对数据进行操作，和NSDictionary实现了LRU淘汰算法。时间复杂度0（1），5种操作基本上都是对头尾节点和链表节点的上一个节点和下一个节点进行操作。\n\n\n## YYMemoryCache\n这边介绍两个主要的操作：添加缓存，查找缓存<p>\n\n- **添加缓存**\n\n```\n- (void)setObject:(id)object forKey:(id)key withCost:(NSUInteger)cost {\n    if (!key) return;\n    if (!object) {\n        // 缓存对象为nil，直接移除\n        [self removeObjectForKey:key];\n        return;\n    }\n    // 为了保证线程安全，数据操作前进行加锁\n    pthread_mutex_lock(&_lock);\n    // 查找缓存\n    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru->_dic, (__bridge const void *)(key));\n    // 当前时间\n    NSTimeInterval now = CACurrentMediaTime();\n    if (node) {\n        // 缓存对象已存在，更新数据，并移到栈顶\n        _lru->_totalCost -= node->_cost;\n        _lru->_totalCost += cost;\n        node->_cost = cost;\n        node->_time = now;\n        node->_value = object;\n        [_lru bringNodeToHead:node];\n    } else {\n        // 缓存对象不存在，添加数据，并移到栈顶\n        node = [_YYLinkedMapNode new];\n        node->_cost = cost;\n        node->_time = now;\n        node->_key = key;\n        node->_value = object;\n        [_lru insertNodeAtHead:node];\n    }\n    // 判断当前的缓存进行是否超出了设定值，若超出则进行整理\n    if (_lru->_totalCost > _costLimit) {\n        dispatch_async(_queue, ^{\n            [self trimToCost:_costLimit];\n        });\n    }\n    \n    // 每次添加数据仅有一个，数量上超出时，直接移除尾部那个object即可\n    if (_lru->_totalCount > _countLimit) {\n        _YYLinkedMapNode *node = [_lru removeTailNode];\n        if (_lru->_releaseAsynchronously) {\n            dispatch_queue_t queue = _lru->_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();\n            dispatch_async(queue, ^{\n                [node class]; //hold and release in queue\n            });\n        } else if (_lru->_releaseOnMainThread && !pthread_main_np()) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [node class]; //hold and release in queue\n            });\n        }\n    }\n    // 操作结束，解锁\n    pthread_mutex_unlock(&_lock);\n}\n\n```\n\n- **异步线程释放**\n![](http://7xq5ax.com1.z0.glb.clouddn.com/%E5%BC%82%E6%AD%A5%E9%87%8A%E6%94%BE.png)\n里面很多都用到类似的方法，将一个对象在异步线程中释放，来分析下：<br>\n\n\n\t\t- p\n\t\t1. 首先通过node来对其进行持有，以至于不会在方法调用结束的时候被销毁\n\t\t2. 我要要在其他线程中进行销毁，所以将销毁操作放在block中，block就会对其进行持有\n\t\t3. 这边在block中随便调用了个方法，保证编译器不会优化掉这个操作\n\t\t4. 当block结束后，node没有被持有的时候，就会在当前线程被release掉了\n\n\n\n- **添加缓存**\n\n```\n// 这边从memory中取数据时，根据LRU原则，将最新取出的object放到栈头\n- (id)objectForKey:(id)key {\n    if (!key) return nil;\n    pthread_mutex_lock(&_lock);\n    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru->_dic, (__bridge const void *)(key));\n    if (node) {\n        node->_time = CACurrentMediaTime();\n        [_lru bringNodeToHead:node];\n    }\n    pthread_mutex_unlock(&_lock);\n    return node ? node->_value : nil;\n}\n\n```\n\n## YYKVStorage\n\n该文件主要以两种方式来实现磁盘存储：SQLite、File，使用两种方式混合进行存储主要为了提高读写效率。写入数据时，SQLite要比文件的方式更快；读取数据的速度主要取决于文件的大小。据测试，在iPhone6中，当文件大小超过20kb时，File要比SQLite快的多。所以当大文件存储时建议用File的方式，小文件更适合用SQLite。<p>\n下边分别对Save、Remove、Get分别进行分析\n\n\n- **Save**\n\n```\n- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(NSString *)filename extendedData:(NSData *)extendedData {\n    // 条件不符合\n    if (key.length == 0 || value.length == 0) return NO;\n    if (_type == YYKVStorageTypeFile && filename.length == 0) {\n        return NO;\n    }\n    \n    if (filename.length) {    // filename存在 SQLite File两种方式并行\n        // 用文件进行存储\n        if (![self _fileWriteWithName:filename data:value]) {\n            return NO;\n        }\n        // 用SQLite进行存储\n        if (![self _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) {\n            // 当使用SQLite方式存储失败时，删除本地文件存储\n            [self _fileDeleteWithName:filename];\n            return NO;\n        }\n        return YES;\n    } else {               // filename不存在 SQLite\n        if (_type != YYKVStorageTypeSQLite) {\n            // 这边去到filename后，删除filename对应的file文件\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            if (filename) {\n                [self _fileDeleteWithName:filename];\n            }\n        }\n        // SQLite 进行存储\n        return [self _dbSaveWithKey:key value:value fileName:nil extendedData:extendedData];\n    }\n}\n\n\n```\n\n- **Remove**\n\n```\n- (BOOL)removeItemForKey:(NSString *)key {\n    if (key.length == 0) return NO;\n    switch (_type) {\n        case YYKVStorageTypeSQLite: {\n            // 删除SQLite文件\n            return [self _dbDeleteItemWithKey:key];\n        } break;\n        case YYKVStorageTypeFile:\n        case YYKVStorageTypeMixed: {\n            // 获取filename\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            if (filename) {\n                // 删除filename对的file\n                [self _fileDeleteWithName:filename];\n            }\n            // 删除SQLite文件\n            return [self _dbDeleteItemWithKey:key];\n        } break;\n        default: return NO;\n    }\n}\n\n```\n\n- **Get**\n\n```\n- (NSData *)getItemValueForKey:(NSString *)key {\n    if (key.length == 0) return nil;\n    NSData *value = nil;\n    switch (_type) {\n        case YYKVStorageTypeFile: { //File\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            if (filename) {\n                // 根据filename获取File\n                value = [self _fileReadWithName:filename];\n                if (!value) {\n                    // 当value不存在，用对应的key删除SQLite文件\n                    [self _dbDeleteItemWithKey:key];\n                    value = nil;\n                }\n            }\n        } break;\n        case YYKVStorageTypeSQLite: {\n            // SQLite 方式获取\n            value = [self _dbGetValueWithKey:key];\n        } break;\n        case YYKVStorageTypeMixed: {\n            NSString *filename = [self _dbGetFilenameWithKey:key];\n            // filename 存在文件获取，不存在SQLite方式获取\n            if (filename) {\n                value = [self _fileReadWithName:filename];\n                if (!value) {\n                    [self _dbDeleteItemWithKey:key];\n                    value = nil;\n                }\n            } else {\n                value = [self _dbGetValueWithKey:key];\n            }\n        } break;\n    }\n    if (value) {\n        // 更新文件操作时间\n        [self _dbUpdateAccessTimeWithKey:key];\n    }\n    return value;\n}\n\n```\n\nFile方式主要使用的writeToFile进行存储，SQLte直接使用的sqlite3来对文件进行操作，具体数据库相关的操作这边就不在进行分析了，感兴趣的自己可以阅读下\n\n## YYDiskCache\n\nYYDiskCache是对YYKVStorage进行的一次封装，是线程安全的，这边使用的是dispatch_semaphore_signal来确保线程的安全。另外他结合LRU算法，根据文件的大小自动选择存储方式来达到更好的性能。\n\n```\n- (instancetype)initWithPath:(NSString *)path\n             inlineThreshold:(NSUInteger)threshold {\n    self = [super init];\n    if (!self) return nil;\n    \n    // 获取缓存的 YYDiskCache\n    YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);\n    if (globalCache) return globalCache;\n    \n    // 确定存储的方式\n    YYKVStorageType type;\n    if (threshold == 0) {\n        type = YYKVStorageTypeFile;\n    } else if (threshold == NSUIntegerMax) {\n        type = YYKVStorageTypeSQLite;\n    } else {\n        type = YYKVStorageTypeMixed;\n    }\n    \n    // 初始化 YYKVStorage\n    YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type];\n    if (!kv) return nil;\n    \n    // 初始化数据\n    _kv = kv;\n    _path = path;\n    _lock = dispatch_semaphore_create(1);\n    _queue = dispatch_queue_create(\"com.ibireme.cache.disk\", DISPATCH_QUEUE_CONCURRENT);\n    _inlineThreshold = threshold;\n    _countLimit = NSUIntegerMax;\n    _costLimit = NSUIntegerMax;\n    _ageLimit = DBL_MAX;\n    _freeDiskSpaceLimit = 0;\n    _autoTrimInterval = 60;\n    \n    // 递归的去整理文件\n    [self _trimRecursively];\n    // 对当前对象进行缓存\n    _YYDiskCacheSetGlobal(self);\n    \n    // 通知 APP即将被杀死时\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_appWillBeTerminated) name:UIApplicationWillTerminateNotification object:nil];\n    return self;\n}\n\n```\n\n其他的一些操作基本上都是对YYKVStorage的一些封装，这边就不一一分析了。\n\n## 参考文献\n\n1. http://blog.ibireme.com/2015/10/26/yycache/\n2. http://blog.csdn.net/yunhua_lee/article/details/7599671\n","slug":"YYCache-analyzing","published":1,"updated":"2016-08-25T03:46:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciup60i2g000rtlcht3jspa8u"},{"title":"迟来的2015总结","date":"2016-01-17T12:08:19.000Z","_content":"纪念逝去的2015！\n<!--more-->\n\n  2016年已经过了半个月了，才抽出时间来写这篇总结。以前很少有写博客的习惯，每年基本上都是考虑下去年做了些什么事，学到了什么等等。可能前一个月内还属于记忆犹新的阶段，现在想想，却什么也记不起来了。就在前段时间，在简书上写了两篇博文感觉挺好的，写博客能让我知道我这段时间做了什么事，并且当我闲下来的时候还可以回味一下，这种感觉真的很好，我会带着这种感觉一直坚持下去。\n\n  就在这周一天早上上班的路上，突然发现一片博客讲如何利用hexo搭建自己的博客，当时让我兴趣盎然，就有搭建自己博客的冲动，在工作的业余时间里慢慢的开始搭建自己的博客，搭建环境，购买域名，云储存等等。直到现在自己的博客终于有点样子了，不过说实话，身为一个处女座，一个追求完美主义者，一大半的时间花在主题了，换了一个不满意，换了一个还是不满意。最终，现在的这个样式自己感觉还是挺可以的。以后我会帮精力花在内容上，希望大家能够喜欢吧。\n\n  说说我的2015年吧，2015年最大变化莫过于我的工作地点从合肥换到了上海，和合肥的一大帮朋友分割两地。说实话，当初要不是同事纷纷离开公司的话我也不会这么快来到上海，在合房网的时候，最幸运的是有一群比较给力的同事，让我迅速的进步了不少。坤坤：让我知道了什么是全能，宪：让我知道了英语的重要性还有一些学习方法。挺：让我知道了一些做人做事的方法还有他那丰富的项目经验。从他们的身上我真的学到了很多，虽然我现在来到了上海，在工作中遇到一些不解也会不时的去请教他们。\n\n2015年也有很多遗憾：\n\n*  没能够看几本书\n*  工作的业余时间也没有去锻炼\n*  swift才开始学\n\n2016年我要：\n\n* 多看几本书，虽然自己不太爱看书\n* 和室友办张健身卡，每天抽出点时间健身去\n* 努力学习swift\n* 每个月写一篇博客\n* 多掌握几门语言，像javascript\n* 扩展自己的社交圈\n\n不知不觉的扯了这么多，废话就不多说了， 洗洗睡了。","source":"_posts/Summary.md","raw":"---\ntitle: 迟来的2015总结\ndate: 2016-01-17 20:08:19\ncategories: life\ntags:\n---\n纪念逝去的2015！\n<!--more-->\n\n  2016年已经过了半个月了，才抽出时间来写这篇总结。以前很少有写博客的习惯，每年基本上都是考虑下去年做了些什么事，学到了什么等等。可能前一个月内还属于记忆犹新的阶段，现在想想，却什么也记不起来了。就在前段时间，在简书上写了两篇博文感觉挺好的，写博客能让我知道我这段时间做了什么事，并且当我闲下来的时候还可以回味一下，这种感觉真的很好，我会带着这种感觉一直坚持下去。\n\n  就在这周一天早上上班的路上，突然发现一片博客讲如何利用hexo搭建自己的博客，当时让我兴趣盎然，就有搭建自己博客的冲动，在工作的业余时间里慢慢的开始搭建自己的博客，搭建环境，购买域名，云储存等等。直到现在自己的博客终于有点样子了，不过说实话，身为一个处女座，一个追求完美主义者，一大半的时间花在主题了，换了一个不满意，换了一个还是不满意。最终，现在的这个样式自己感觉还是挺可以的。以后我会帮精力花在内容上，希望大家能够喜欢吧。\n\n  说说我的2015年吧，2015年最大变化莫过于我的工作地点从合肥换到了上海，和合肥的一大帮朋友分割两地。说实话，当初要不是同事纷纷离开公司的话我也不会这么快来到上海，在合房网的时候，最幸运的是有一群比较给力的同事，让我迅速的进步了不少。坤坤：让我知道了什么是全能，宪：让我知道了英语的重要性还有一些学习方法。挺：让我知道了一些做人做事的方法还有他那丰富的项目经验。从他们的身上我真的学到了很多，虽然我现在来到了上海，在工作中遇到一些不解也会不时的去请教他们。\n\n2015年也有很多遗憾：\n\n*  没能够看几本书\n*  工作的业余时间也没有去锻炼\n*  swift才开始学\n\n2016年我要：\n\n* 多看几本书，虽然自己不太爱看书\n* 和室友办张健身卡，每天抽出点时间健身去\n* 努力学习swift\n* 每个月写一篇博客\n* 多掌握几门语言，像javascript\n* 扩展自己的社交圈\n\n不知不觉的扯了这么多，废话就不多说了， 洗洗睡了。","slug":"Summary","published":1,"updated":"2016-08-25T04:28:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciup60i2i000wtlch1j7r7dn4"},{"title":"浅谈Socket学习中的那些事","date":"2016-01-16T13:17:20.000Z","_content":"\nSocket是为网络服务提供的一种机制，希望经过此次的学习，能够揭开Socket神秘面纱。在此仅想记录自己的学习历程和一些学习心得。\n<!--more-->\n\n# OSI、TCP\\IP参考模型\n<p>\n\n![](http://7xq5ax.com1.z0.glb.clouddn.com/OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.png)\n<p>\n\n## 简单解释\n\n1. 物理层：主要定义物理设备标准，如网线的接口类型、各种传输介质的传输速率等。2. \n\n2. 数据链路层：主要将从物理层接收的数据进行MAC地址的封装与解封装。\n\n3. 网络层：选择合适的网间路由和交换结点，确保数据及时传送，将从下层接收到的数据进行IP地址的封装与解封装。\n\n4. 传输层：定义了一些传输数据的协议和端口，如TCP、UDP协议，主要将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，以往把这一层数据叫做段。\n\n5. 会话层：通过传输层建立数据传输通路。\n\n6. 表示层：主要是进行对接收的数据进行解释、压缩与解压缩等，即把计算机能够识别的东西转化成人能够识别的东西（如图片、声音等）。\n\n7. 应用层：主要是一些终端的应用，比如说FTP（各种文件下载）、浏览器、QQ等，可以将其理解为在电脑屏幕上可以看到的东西，也就是终端应用。<p>\n\n## 网络通讯要素\n\n**IP地址**：网络中设备的标示\n\n**端口号**：用来标示进程的逻辑地址，不同进程的标示\n\n**传输协议**：用什么样的方式进行交互，常见协议TCP/UDP\n\n# TCP/UDP\n\n**TCP（传输控制协议）**\n\n1. 建立连接，形成数据传输的通道\n\n2. 在连接中可进行大数据传输（数据的大小不受限制）\n\n3. 通过三次握手建立连接，可靠协议，安全送达\n\n4. 先建立连接，效率较低<p>\n\n**UDP（用户数据报协议）**\n\n1. 不需要建立连接，将数据封装在数据包中\n\n2. 每个数据包得大小限制在64k之内\n\n3. 无需连接，是不可靠协议\n\n4. 不需要连接，速度较快\n\n\n# Socket\n\n## 简单解释\n\n1. 网络提供服务的一种机制\n \n2. 通信的两端都是socket\n\n3. 网络通信其实就是socket间的通信\n\n4. 数据在两个socket间通过IO传输\n\n![](http://7xq5ax.com1.z0.glb.clouddn.com/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81.png)\n\n## iOS中常用的两种Socket类型\n\n**流式Socket（SOCK_STREAM）**：流式是一种面向连接的Socket，针对于面向连接的TCP服务应用\n\n**数据报式Socket（SOCK_DGRAM）**：数据报式Socket是一种无连接的Socket，对应于无连接的UDP服务应用\n\n## Http与Socket的区别\n\n1. Http是基于Socket的实现；Http应用层协议，主要解决如何包装数据\n\n2. Http传输的数据格式是规定好的，Socket实现数据传输是最原始，Socket实现的数据传输格式可自定义\n\n3. Http建立的连接称为短连接，Socket建立的连接为长连接\n\n4. Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API),通过Socket我们才能使用TCP/IP协议\n\n# 最后\n<p>\n在学习的过程中会模仿微信做类似的demo，涉及到的一些相关地址如下：\n\n1. iOS XMPP框架：https://github.com/robbiehanson/XMPPFramework\n\n2. Server：http://www.igniterealtime.org/downloads/index.jsp\n\n3. 数据库：http://dev.mysql.com/downloads/mysql/\n\n\n\n\n\n\n\n\n","source":"_posts/Socket.md","raw":"---\ntitle: 浅谈Socket学习中的那些事\ndate: 2016-01-16 21:17:20\ncategories: iOS\ntags: [SOCKET, HTTP, TCP, UDP]\n---\n\nSocket是为网络服务提供的一种机制，希望经过此次的学习，能够揭开Socket神秘面纱。在此仅想记录自己的学习历程和一些学习心得。\n<!--more-->\n\n# OSI、TCP\\IP参考模型\n<p>\n\n![](http://7xq5ax.com1.z0.glb.clouddn.com/OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.png)\n<p>\n\n## 简单解释\n\n1. 物理层：主要定义物理设备标准，如网线的接口类型、各种传输介质的传输速率等。2. \n\n2. 数据链路层：主要将从物理层接收的数据进行MAC地址的封装与解封装。\n\n3. 网络层：选择合适的网间路由和交换结点，确保数据及时传送，将从下层接收到的数据进行IP地址的封装与解封装。\n\n4. 传输层：定义了一些传输数据的协议和端口，如TCP、UDP协议，主要将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，以往把这一层数据叫做段。\n\n5. 会话层：通过传输层建立数据传输通路。\n\n6. 表示层：主要是进行对接收的数据进行解释、压缩与解压缩等，即把计算机能够识别的东西转化成人能够识别的东西（如图片、声音等）。\n\n7. 应用层：主要是一些终端的应用，比如说FTP（各种文件下载）、浏览器、QQ等，可以将其理解为在电脑屏幕上可以看到的东西，也就是终端应用。<p>\n\n## 网络通讯要素\n\n**IP地址**：网络中设备的标示\n\n**端口号**：用来标示进程的逻辑地址，不同进程的标示\n\n**传输协议**：用什么样的方式进行交互，常见协议TCP/UDP\n\n# TCP/UDP\n\n**TCP（传输控制协议）**\n\n1. 建立连接，形成数据传输的通道\n\n2. 在连接中可进行大数据传输（数据的大小不受限制）\n\n3. 通过三次握手建立连接，可靠协议，安全送达\n\n4. 先建立连接，效率较低<p>\n\n**UDP（用户数据报协议）**\n\n1. 不需要建立连接，将数据封装在数据包中\n\n2. 每个数据包得大小限制在64k之内\n\n3. 无需连接，是不可靠协议\n\n4. 不需要连接，速度较快\n\n\n# Socket\n\n## 简单解释\n\n1. 网络提供服务的一种机制\n \n2. 通信的两端都是socket\n\n3. 网络通信其实就是socket间的通信\n\n4. 数据在两个socket间通过IO传输\n\n![](http://7xq5ax.com1.z0.glb.clouddn.com/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81.png)\n\n## iOS中常用的两种Socket类型\n\n**流式Socket（SOCK_STREAM）**：流式是一种面向连接的Socket，针对于面向连接的TCP服务应用\n\n**数据报式Socket（SOCK_DGRAM）**：数据报式Socket是一种无连接的Socket，对应于无连接的UDP服务应用\n\n## Http与Socket的区别\n\n1. Http是基于Socket的实现；Http应用层协议，主要解决如何包装数据\n\n2. Http传输的数据格式是规定好的，Socket实现数据传输是最原始，Socket实现的数据传输格式可自定义\n\n3. Http建立的连接称为短连接，Socket建立的连接为长连接\n\n4. Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API),通过Socket我们才能使用TCP/IP协议\n\n# 最后\n<p>\n在学习的过程中会模仿微信做类似的demo，涉及到的一些相关地址如下：\n\n1. iOS XMPP框架：https://github.com/robbiehanson/XMPPFramework\n\n2. Server：http://www.igniterealtime.org/downloads/index.jsp\n\n3. 数据库：http://dev.mysql.com/downloads/mysql/\n\n\n\n\n\n\n\n\n","slug":"Socket","published":1,"updated":"2016-08-25T03:50:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciup60i2l000ztlchyoumz6xn"},{"title":"Runtime实战之定制TabBarItem大小","date":"2016-05-11T14:17:26.000Z","_content":"本篇blog主要讲解如何定制TabBarItem的大小，最终实现AppStore各大主流APP TabBarItem超出TabBar的效果。\n<!--more-->\n\n# 方案一：UIEdgeInsets\n**适用场景：** <br>\n\n- 适合APP的TabBarItemImage的图片资源放在本地\n- 图片超出tabbar的高度，需移动其位置，来进行适应\n\n**弊端：** <br>\n\n若在本地配置好后，tabbar的图片就不能改动了，若tabbar的图片来自服务端，且不停的切换图片的大小，以上则很难满足。若有此方面的需求请看方案二。\n\n**实现：** <br>\n\n` [tabbarItem setImageInsets:UIEdgeInsetsMake(<#CGFloat top#>, <#CGFloat left#>, <#CGFloat bottom#>, <#CGFloat right#>)]` \n\n注：图片太大超出tabbar时，系统并不会调整image和title的位置，你需要根据图片的高度，计算出需要往上移动的高度，然后设置top和bottom属性即可。切记top = - bottom，否则image将会被拉伸或者被压缩。\n\n\n# 方案二：Runtime\n利用runtime的话相对方案一来说要比较复杂一点，但其灵活度比较高，我们能够根据服务端所给的image来动态的变化TabBarItem的大小，类似像淘宝、京东活动时。思想：主要是利用runtime对UITabBar的layoutSubviews进行重写，然后调整UITabBarItem的位置。另外，当时在做的APP已经有4-5年的历史了，一开始打算自已定制tabbar，发现要改动的还是挺多的，于是就放弃了。做之前也看了前辈iOS程序犭袁的[CYLTabBarController](https://github.com/ChenYilong/CYLTabBarController)，从中也学到了不少思路。\n\n\n**实现：** <br>\n1. 首先我们使用runtime method swizzling交换系统的`- (void)layoutSubviews;` <br>\n2. 使用KVC对系统的UITabBarButton、UITabBarSwappableImageView、UITabBarButtonLabel、_UIBadgeView进行捕获 <br> \n3. 拿到控件后我们对其的frame进行计算，判断当前有没有超出tabbar的高度，若超出则进行处理 <br>\n4. 再次利用runtime method swizzling交换系统的`- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;`使图片超过后也能接受点击 <br>\n\n**代码：** <br>\n\n- method swizzling：\n\n```\nstatic void ExchangedMethod(SEL originalSelector, SEL swizzledSelector, Class class) {\n    \n    Method originalMethod = class_getInstanceMethod(class, originalSelector);\n    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n    \n    BOOL didAddMethod =\n    class_addMethod(class,\n                    originalSelector,\n                    method_getImplementation(swizzledMethod),\n                    method_getTypeEncoding(swizzledMethod));\n    \n    if (didAddMethod) {\n        class_replaceMethod(class,\n                            swizzledSelector,\n                            method_getImplementation(originalMethod),\n                            method_getTypeEncoding(originalMethod));\n    }\n    else {\n        method_exchangeImplementations(originalMethod, swizzledMethod);\n    }\n}\n\n```\n- 计算frame，并对其重新布局\n\n```\nUIView *tabBarImageView, *tabBarButtonLabel, *tabBarBadgeView;\n        for (UIView *sTabBarItem in childView.subviews) {\n            if ([sTabBarItem isKindOfClass:NSClassFromString(@\"UITabBarSwappableImageView\")]) {\n                tabBarImageView = sTabBarItem;\n            }\n            else if ([sTabBarItem isKindOfClass:NSClassFromString(@\"UITabBarButtonLabel\")]) {\n                tabBarButtonLabel = sTabBarItem;\n            }\n            else if ([sTabBarItem isKindOfClass:NSClassFromString(@\"_UIBadgeView\")]) {\n                tabBarBadgeView = sTabBarItem;\n            }\n        }\n\n        NSString *tabBarButtonLabelText = ((UILabel *)tabBarButtonLabel).text;\n  \n        CGFloat y = CGRectGetHeight(self.bounds) - (CGRectGetHeight(tabBarButtonLabel.bounds) + CGRectGetHeight(tabBarImageView.bounds));\n        if (y < 3) {\n            if (!tabBarButtonLabelText.length) {\n                space -= tabBarButtonLabelHeight;\n            }\n            \n            childView.frame = CGRectMake(childView.frame.origin.x,\n                                         y - space,\n                                         childView.frame.size.width,\n                                         childView.frame.size.height - y + space\n                                         );\n        }\n\n```\n\n- 让图片超出部分也能响应点击事件\n\n```\n- (UIView *)s_hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n    if (!self.clipsToBounds && !self.hidden && self.alpha > 0) {\n        UIView *result = [super hitTest:point withEvent:event];\n        if (result) {\n            return result;\n        }\n        else {\n            for (UIView *subview in self.subviews.reverseObjectEnumerator) {\n                CGPoint subPoint = [subview convertPoint:point fromView:self];\n                result = [subview hitTest:subPoint withEvent:event];\n                if (result) {\n                    return result;\n                }\n            }\n        }\n    }\n    return nil;\n}\n\n```\n# 注意事项\n\n- 在给tabbar设置图片的时候一定要设置图片的`renderingMode`，否则就会出现下图中图片丢失的现象\n- UITabBarButton被修改frame之后，仅有UITabBarSwappableImageView能够响应点击事件，不过我们能够在UITabBar的`- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;`方法中捕获到\n- 当适配图片后不要忘记适配`_UIBadgeView`的frame\n\n\n# 效果图\n- 正常中间超出 <br>\n![部分超出](http://7xq5ax.com1.z0.glb.clouddn.com/tabbar_image_render.png)<br>\n- 做活动时全部超出 <br>\n![全部超出](http://7xq5ax.com1.z0.glb.clouddn.com/tabbar_more_all.png)<br>\n- 图片丢失 <br>\n![图片丢失](http://7xq5ax.com1.z0.glb.clouddn.com/tabbar_more.png)<br>\n- UIBadgeView <br>\n![](http://7xq5ax.com1.z0.glb.clouddn.com/badgevalue.png)\n\n> 感谢大家花费时间来查看这篇blog，需要下载demo的同学请猛戳[Git](https://github.com/PanXianyue/BlogDemo)。","source":"_posts/Runtime-tabBarItem.md","raw":"---\ntitle: Runtime实战之定制TabBarItem大小\ndate: 2016-05-11 22:17:26\ncategories: iOS\ntags:\n---\n本篇blog主要讲解如何定制TabBarItem的大小，最终实现AppStore各大主流APP TabBarItem超出TabBar的效果。\n<!--more-->\n\n# 方案一：UIEdgeInsets\n**适用场景：** <br>\n\n- 适合APP的TabBarItemImage的图片资源放在本地\n- 图片超出tabbar的高度，需移动其位置，来进行适应\n\n**弊端：** <br>\n\n若在本地配置好后，tabbar的图片就不能改动了，若tabbar的图片来自服务端，且不停的切换图片的大小，以上则很难满足。若有此方面的需求请看方案二。\n\n**实现：** <br>\n\n` [tabbarItem setImageInsets:UIEdgeInsetsMake(<#CGFloat top#>, <#CGFloat left#>, <#CGFloat bottom#>, <#CGFloat right#>)]` \n\n注：图片太大超出tabbar时，系统并不会调整image和title的位置，你需要根据图片的高度，计算出需要往上移动的高度，然后设置top和bottom属性即可。切记top = - bottom，否则image将会被拉伸或者被压缩。\n\n\n# 方案二：Runtime\n利用runtime的话相对方案一来说要比较复杂一点，但其灵活度比较高，我们能够根据服务端所给的image来动态的变化TabBarItem的大小，类似像淘宝、京东活动时。思想：主要是利用runtime对UITabBar的layoutSubviews进行重写，然后调整UITabBarItem的位置。另外，当时在做的APP已经有4-5年的历史了，一开始打算自已定制tabbar，发现要改动的还是挺多的，于是就放弃了。做之前也看了前辈iOS程序犭袁的[CYLTabBarController](https://github.com/ChenYilong/CYLTabBarController)，从中也学到了不少思路。\n\n\n**实现：** <br>\n1. 首先我们使用runtime method swizzling交换系统的`- (void)layoutSubviews;` <br>\n2. 使用KVC对系统的UITabBarButton、UITabBarSwappableImageView、UITabBarButtonLabel、_UIBadgeView进行捕获 <br> \n3. 拿到控件后我们对其的frame进行计算，判断当前有没有超出tabbar的高度，若超出则进行处理 <br>\n4. 再次利用runtime method swizzling交换系统的`- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;`使图片超过后也能接受点击 <br>\n\n**代码：** <br>\n\n- method swizzling：\n\n```\nstatic void ExchangedMethod(SEL originalSelector, SEL swizzledSelector, Class class) {\n    \n    Method originalMethod = class_getInstanceMethod(class, originalSelector);\n    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n    \n    BOOL didAddMethod =\n    class_addMethod(class,\n                    originalSelector,\n                    method_getImplementation(swizzledMethod),\n                    method_getTypeEncoding(swizzledMethod));\n    \n    if (didAddMethod) {\n        class_replaceMethod(class,\n                            swizzledSelector,\n                            method_getImplementation(originalMethod),\n                            method_getTypeEncoding(originalMethod));\n    }\n    else {\n        method_exchangeImplementations(originalMethod, swizzledMethod);\n    }\n}\n\n```\n- 计算frame，并对其重新布局\n\n```\nUIView *tabBarImageView, *tabBarButtonLabel, *tabBarBadgeView;\n        for (UIView *sTabBarItem in childView.subviews) {\n            if ([sTabBarItem isKindOfClass:NSClassFromString(@\"UITabBarSwappableImageView\")]) {\n                tabBarImageView = sTabBarItem;\n            }\n            else if ([sTabBarItem isKindOfClass:NSClassFromString(@\"UITabBarButtonLabel\")]) {\n                tabBarButtonLabel = sTabBarItem;\n            }\n            else if ([sTabBarItem isKindOfClass:NSClassFromString(@\"_UIBadgeView\")]) {\n                tabBarBadgeView = sTabBarItem;\n            }\n        }\n\n        NSString *tabBarButtonLabelText = ((UILabel *)tabBarButtonLabel).text;\n  \n        CGFloat y = CGRectGetHeight(self.bounds) - (CGRectGetHeight(tabBarButtonLabel.bounds) + CGRectGetHeight(tabBarImageView.bounds));\n        if (y < 3) {\n            if (!tabBarButtonLabelText.length) {\n                space -= tabBarButtonLabelHeight;\n            }\n            \n            childView.frame = CGRectMake(childView.frame.origin.x,\n                                         y - space,\n                                         childView.frame.size.width,\n                                         childView.frame.size.height - y + space\n                                         );\n        }\n\n```\n\n- 让图片超出部分也能响应点击事件\n\n```\n- (UIView *)s_hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n    if (!self.clipsToBounds && !self.hidden && self.alpha > 0) {\n        UIView *result = [super hitTest:point withEvent:event];\n        if (result) {\n            return result;\n        }\n        else {\n            for (UIView *subview in self.subviews.reverseObjectEnumerator) {\n                CGPoint subPoint = [subview convertPoint:point fromView:self];\n                result = [subview hitTest:subPoint withEvent:event];\n                if (result) {\n                    return result;\n                }\n            }\n        }\n    }\n    return nil;\n}\n\n```\n# 注意事项\n\n- 在给tabbar设置图片的时候一定要设置图片的`renderingMode`，否则就会出现下图中图片丢失的现象\n- UITabBarButton被修改frame之后，仅有UITabBarSwappableImageView能够响应点击事件，不过我们能够在UITabBar的`- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;`方法中捕获到\n- 当适配图片后不要忘记适配`_UIBadgeView`的frame\n\n\n# 效果图\n- 正常中间超出 <br>\n![部分超出](http://7xq5ax.com1.z0.glb.clouddn.com/tabbar_image_render.png)<br>\n- 做活动时全部超出 <br>\n![全部超出](http://7xq5ax.com1.z0.glb.clouddn.com/tabbar_more_all.png)<br>\n- 图片丢失 <br>\n![图片丢失](http://7xq5ax.com1.z0.glb.clouddn.com/tabbar_more.png)<br>\n- UIBadgeView <br>\n![](http://7xq5ax.com1.z0.glb.clouddn.com/badgevalue.png)\n\n> 感谢大家花费时间来查看这篇blog，需要下载demo的同学请猛戳[Git](https://github.com/PanXianyue/BlogDemo)。","slug":"Runtime-tabBarItem","published":1,"updated":"2016-08-25T13:12:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciup60i2p0019tlchz6qhwumh"}],"PostAsset":[],"PostCategory":[{"post_id":"ciup60i1d0000tlchp75c8r9c","category_id":"ciup60i1j0001tlch3ac9czp8","_id":"ciup60i1n0004tlch4h9rnnfz"},{"post_id":"ciup60i25000ctlchg7an26to","category_id":"ciup60i1j0001tlch3ac9czp8","_id":"ciup60i27000dtlchglewzthc"},{"post_id":"ciup60i2c000ltlchdlwvll6y","category_id":"ciup60i1j0001tlch3ac9czp8","_id":"ciup60i2d000mtlchfpuj23cs"},{"post_id":"ciup60i2g000rtlcht3jspa8u","category_id":"ciup60i1j0001tlch3ac9czp8","_id":"ciup60i2h000stlchj9mxvvy6"},{"post_id":"ciup60i2i000wtlch1j7r7dn4","category_id":"ciup60i2j000xtlchdaq92akx","_id":"ciup60i2k000ytlchpl6pgwgo"},{"post_id":"ciup60i2l000ztlchyoumz6xn","category_id":"ciup60i1j0001tlch3ac9czp8","_id":"ciup60i2m0010tlchuemorgxa"},{"post_id":"ciup60i2p0019tlchz6qhwumh","category_id":"ciup60i1j0001tlch3ac9czp8","_id":"ciup60i2r001atlchr53tqbc0"}],"PostTag":[{"post_id":"ciup60i1d0000tlchp75c8r9c","tag_id":"ciup60i1k0002tlchimzbs841","_id":"ciup60i1n0005tlch5h85wubd"},{"post_id":"ciup60i1d0000tlchp75c8r9c","tag_id":"ciup60i1m0003tlch5fqobacv","_id":"ciup60i1o0006tlcheema60pl"},{"post_id":"ciup60i25000ctlchg7an26to","tag_id":"ciup60i27000etlchc6quzvk7","_id":"ciup60i28000htlchnq986rev"},{"post_id":"ciup60i25000ctlchg7an26to","tag_id":"ciup60i27000ftlch6ww5lwro","_id":"ciup60i28000itlchb40v3iaq"},{"post_id":"ciup60i25000ctlchg7an26to","tag_id":"ciup60i27000gtlchbtg70g02","_id":"ciup60i28000jtlchz48jwyen"},{"post_id":"ciup60i2c000ltlchdlwvll6y","tag_id":"ciup60i2d000ntlchb8ashix4","_id":"ciup60i2f000ptlchjvu6vvsa"},{"post_id":"ciup60i2c000ltlchdlwvll6y","tag_id":"ciup60i2e000otlchdvrkv4l7","_id":"ciup60i2f000qtlch5ohexxt1"},{"post_id":"ciup60i2g000rtlcht3jspa8u","tag_id":"ciup60i2d000ntlchb8ashix4","_id":"ciup60i2h000utlcht09zydqb"},{"post_id":"ciup60i2g000rtlcht3jspa8u","tag_id":"ciup60i2h000ttlchcqs9nq2r","_id":"ciup60i2h000vtlchgdkkameh"},{"post_id":"ciup60i2l000ztlchyoumz6xn","tag_id":"ciup60i2n0011tlchyfn34nqd","_id":"ciup60i2o0015tlchvrtttv9b"},{"post_id":"ciup60i2l000ztlchyoumz6xn","tag_id":"ciup60i2n0012tlchis32p7k5","_id":"ciup60i2o0016tlch4fqym53c"},{"post_id":"ciup60i2l000ztlchyoumz6xn","tag_id":"ciup60i2n0013tlch1gl6q4x0","_id":"ciup60i2o0017tlch4sm5dq93"},{"post_id":"ciup60i2l000ztlchyoumz6xn","tag_id":"ciup60i2o0014tlch11eufzh6","_id":"ciup60i2o0018tlch0cywb0f7"}],"Tag":[{"name":"RSA加密","_id":"ciup60i1k0002tlchimzbs841"},{"name":"SHA签名","_id":"ciup60i1m0003tlch5fqobacv"},{"name":"XCTOOL","_id":"ciup60i27000etlchc6quzvk7"},{"name":"SHELL","_id":"ciup60i27000ftlch6ww5lwro"},{"name":"LINUX命令","_id":"ciup60i27000gtlchbtg70g02"},{"name":"YYKit","_id":"ciup60i2d000ntlchb8ashix4"},{"name":"pthread","_id":"ciup60i2e000otlchdvrkv4l7"},{"name":"YYCache","_id":"ciup60i2h000ttlchcqs9nq2r"},{"name":"SOCKET","_id":"ciup60i2n0011tlchyfn34nqd"},{"name":"HTTP","_id":"ciup60i2n0012tlchis32p7k5"},{"name":"TCP","_id":"ciup60i2n0013tlch1gl6q4x0"},{"name":"UDP","_id":"ciup60i2o0014tlch11eufzh6"}]}}